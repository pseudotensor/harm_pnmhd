 # comp zones only
 # if((k>=0)&&(k<$nz-4)&&(j>=0)&&(j<$ny-4)&&(i>=0)&&(i<$nx-4))
 # all zones
 # if((k>=-2)&&(k<$nz-2)&&(j>=-2)&&(j<$ny-2)&&(i>=-2)&&(i<$nx-2))
 # cut through E0,2,8,10
 # E8,E10
 # if((k>=5)&&(k<$nz-2)&&(j>=-2)&&(j<$ny-2)&&(i>=5)&&(i<$nx-7))
 # E0,E2
 # if((k>=-2)&&(k<$nz-7)&&(j>=-2)&&(j<$ny-2)&&(i>=5)&&(i<$nx-7))
 # cut through E4,5,6,7
 # if((k>=5)&&(k<$nz-7)&&(j>=-2)&&(j<$ny-2)&&(i>=-2)&&(i<$nx-2))
 #
 # if((k>=-2)&&(k<$nz-2)&&(j==$ny/3)&&(i>=-2)&&(i<$nx-2))
 # cut through E3,1,11,9
 # if((k>=-2)&&(k<$nz-2)&&(j>=7)&&(j<=$ny-9)&&(i>=-2)&&(i<$nx-2))
 #
 # if((k==-2)&&(j==$ny/3)&&(i>=-2)&&(i<$nx-2))
 # see other macros: ~/sm/smstart
 #                   /usr/local/lib/sm/macro
 # typical start call:
 # re twod.m gpa 0 rdraft
 # if using older no-ver/type files, then specify type/version manually.
 # define grandpa 1
 # e.g.:
 # define fileversion 1
 # define filetype 3
 #
 #// file versions numbers(use sm for backwards compat)
 #define PVER 6
 #define GRIDVER 2
 #define DVER 1    // dumps same as for pdumps, adumps
 #define FLVER 2
 #define NPVER 2
 #define AVG1DVER 2
 #define AVG2DVER 2
 #define ENERVER 5
 #define LOSSVER 5
 #define SPVER   1
 #define TSVER   1
 #define LOGDTVER 1
 #define STEPVER 1
 #define PERFVER 3
 #define ADVER DVER
 #define PDVER DVER
 #define CALCVER 1
 #// type designations for sm automagical read in correct format for similar things
 #define PTYPE     1 // global par file
 #define GRIDTYPE  2
 #define DTYPE     3 // dump
 #define FLTYPE    4 // floor
 #define NPTYPE    5 // np
 #define AVG2DTYPE 6
 #define AVG1DTYPE 7
 #define ENERTYPE  8
 #define LOSSTYPE  9
 #define SPTYPE    10
 #define TSTYPE    11
 #define LOGDTTYPE 12 
 #define STEPTYPE  13
 #define PERFTYPE  14
 #define ADTYPE    15 // same as dump except filename
 #define PDTYPE    16 // same as dump except filename
 #define CALCTYPE  17 // arbitrary calcs during pp
 #define EXPANDTYPE 50 // used to signify doing pp expansion
 #define NPCOMPUTETYPE 33 // used to signify want to compute np before output
 #
 # ctype default rd dump0001.dat 0 rd adump0001.dat 2 set vxdiff=v0x-v2x pllim 0 x1 vxdiff 150 1100 -1E-10 1E-10
 # ctype red rd dump0001.dat 0 rd adump0001.dat 2 set vxdiff=v0x-v2x plo 0 x1 vxdiff
 # ctype blue rd dump0001.dat 0 rd adump0001.dat 2 set vxdiff=v0x-v2x plo 0 x1 vxdiff
 # ctype green rd dump0001.dat 0 rd adump0001.dat 2 set vxdiff=v0x-v2x plo 0 x1 vxdiff
 # ctype cyan rd dump0001.dat 0 rd adump0001.dat 2 set vxdiff=v0x-v2x plo 0 x1 vxdiff
                   #xla $2
                   #yla $3
                   # relocate (15000 31500)
                   # cp *.m /us1/jon/ndata25
                   # rd /us1/jon/ndata25/0_loss.dat
                   # der t min1 tdn25 min1dn25
                   # ctype blue plo null tdn25 min1dn25
                   # ctype red plo null tdn16 (mx3in1dn16/min1dn16)
                   # relocate (15000 31500)
                   # ctype default label n17 n16 n25 \dot{M}(t)
                   # device postencap /us1/jon/compare/dot/n17n16n25mdot.eps
                   # device postscript
                   # define interp (0) set _gam=(5/3) define gam (_gam) set wgam=1
                   # label n17 n16 n25 \dot{M}(t)
                   #label Mass Accretion rate vs. time
                   #xla tc^3/GM
                   #xla freq GM/c^3
  		   #yla \dot{M}/\dot{M}_{inj}
                   #yla (M/M_{inj})^2
		   #yla \dot{M}_{in} \rho_0 R_0^3 c^3/GM
                   # cp *.m /us1/jon/f8
                   # cat /us1/jon/f8/0_numdumps.dat
                   # device postencap /us1/jon/compare/n28rho.eps
                   # device postscript
                   #
                   #label Power Spectrum of \dot{M_{in}}/\dot{M_{inj}}
                   #label Power Spectrum of \dot{M_{in}}
                   #xla t*GM/c^3
                   #xla Frequency*c^3/GM
                   #yla \dot{M_{in}}/\dot{M_{inj}}
                   #yla Power*(c^2/GM)^2
                   #yla \dot{M_{in}} \rho_0 R_0^3
                   #xla $2
                   #yla $3
                   #
                #lweight 2
                #limits 0 23.1 -23.1 23.1
                #xla Rc^2/GM
                #yla zc^2/GM
                #yla \theta
                #
		#read {x 1 y 2 r 3}
                # ticksize -1 0 0 0
                # device postencap /us1/jon/compare/a1all/1d/r1d1.eps
                # pl 0 x2 en1d1
                # pl 0 (LG(x1)) en1d1
                # relocate (10383 31500) label \rho(\theta)
                # device X11
                #
                # global test functions for injection runs:
                # derived from r=1.05rg..20rg injection runs on alphadog/wiseguy
                # set testrho=exp(-(x2-3.14159*0.5)**2/(0.4**2))*0.012*(x1-2)**(.4)
                # K=en/rho^gam
                # set test1ok=exp(-(x2-3.14159*0.5)**2/(0.5**2))*2.33*(x1-2)**(.51)
                # solve this for en
                # set testen=(1/test1ok)*testrho**($gam)
                # set testvx=-(-.56*LG(x1-2)+.87)**(1/0.25)

                # set testvy=.6*sin(((x2-0.2)/2.75)*2*3.14159)*(-0.4*(LG((x1-2)/(17))))
                # set testvz=(-.6*LG(x1-2)+1.06)*exp(-(x2-3.14159*0.5)**2/(0.7**2))
                
                # set testvz = 1.2512*(x1-2)**(-.571305)*exp(-(x2-3.14159*0.5)**2/(0.7**2))


                #device postencap god.eps
                #device ppm filename.ppm
gpa       1     #
                define grandpa $1
                if($grandpa){ echo grandpa file }
                #
labeltime 0     #
                if(!($finaldraft)){\
                 if( ($filetype==$DTYPE)||($filetype==$ADTYPE)||($filetype==$PDTYPE)||($filetype==$FLTYPE)||($filetype==$NPTYPE)){\
                   relocate (10383 31500)
                   set tempt=sprintf('%5.2g',$time)
                   define temptime (tempt)
                   #label t=$time
                   label t=$temptime
	 	 }
		}
labelaxes 1     # (e.g. labelaxes 0 will just label and not try to define)
		if($1){ defineaxes }
                xla $x1label
                yla $x2label
defineaxes 0    #
		if(('$paxes1'=='x1')||('$paxes1'=='x12')){\
		 if($coord==3){\
		  if($interp==0){\
		   define x1label "r c^2/GM"
		  }
		  if($interp==1){\
		   define x1label "R c^2/GM"
		  }
		 }
		 if($coord==2){\
		  if($interp==0){\
		   define x1label "r"
		  }
		  if($interp==1){\
		   define x1label "r"
		  }
		 }
		 if($coord==1){\
		  if($interp==0){\
		   define x1label "x"
		  }
		  if($interp==1){\
		   define x1label "x"
		  }
		 }
		}
		if(('$paxes2'=='x1')||('$paxes2'=='x12')){\
		 if($interp==0){\
		  define x2label "r c^2/GM"
		 }
		 if($interp==1){\
		  define x2label "R c^2/GM"
		 }
		}
		if(('$paxes1'=='x2')||('$paxes1'=='x22')){\
		 if($interp==0){\
		  define x1label "\theta"
		 }
		 if($interp==1){\
		  define x1label "z c^2/GM"
		 }
		}
		if(('$paxes2'=='x2')||('$paxes2'=='x22')){\
		 if($coord==3){\
		  if($interp==0){\
		   define x2label "\theta"
		  }
		  if($interp==1){\
		   define x2label "z c^2/GM"
		  }
		 }
		 if($coord==2){\
		  if($interp==0){\
		   define x2label "z"
		  }
		  if($interp==1){\
		   define x2label "z"
		  }
		 }
		 if($coord==1){\
		  if($interp==0){\
		   define x2label "y"
		  }
		  if($interp==1){\
		   define x2label "y"
		  }
		 }
		}
                if('$paxes1'=='r'){\
                    define x1label "\rho"
                }
                if('$paxes1'=='freq'){\
                    define x1label "Hz GM/c^3"
                }
                if('$paxes2'=='min1dfpow'){\
		       define x2label "Power (\dot{M}_{inj} GM/c^3)^2"
                }
                if('$paxes2'=='r'){\
                    define x2label "\rho"
                }
                if('$paxes3'=='r'){\
                    define x3label "\rho"
                }
                if( ($filetype==$MODETYPE)||($filetype==$ENERTYPE)||($filetype==$LOSSTYPE)||($filetype==$SPTYPE)||($filetype==$TSTYPE)){\
		 if( ('$paxes1'=='t')||('$paxes1'=='td') ){\
		  define x1label "t c^3/GM"
		 }
		 if('$paxes2'=='min1d'){\
		        define x2label "\dot{M}/\dot{M}_{inj}"
		 }
		 if('$paxes2'=='(ein1d/min1d)'){\
		        define x2label "\dot{E}^{tot}/\dot{M}"
		 }
		 if('$paxes2'=='(mx3in1d/min1d)'){\
		  define x2label "\dot{L}/\dot{M}"
		 }
		}                
                #
labelaxes3 3    #
                defineaxes
                label3 x $1 $x1label
                label3 y $2 $x2label
                label3 z $3 $x3label
                #
prepaxes 13     # Used since processing can use odd names sent to plot macro
                define paxes1 $1
                define paxes2 $2
                if($?3 == 1){\
                 define paxes3 $3
                }\
                else{\
                 define paxes3 (0)
                }
                #
mybox2d 0       # assumes xl,xh,yl,yh already set(hack for plc since contour doesn't know about grid!)
                # not really correct for anything but pure log grids(lg(r)), i.e. can't do axes right for lg(r-2)
                if( ($interp==1)||($coord==1)||($coord==2) ){\
                 ticksize 0 0 0 0
		 box
	        }\
                else{\
		 if(1==1){\
		  ticksize -1 0 0 0
                  # redo limits for log10 in x1
		  set _newxl=LG($xl)
	      	  define newxl (_newxl)
       		  set _newxh=LG($xh)
	          define newxh (_newxh)
		  set _newyl=$yl
		  define newyl (_newyl)
		  set _newyh=$yh
		  define newyh (_newyh)
		  limits  $newxl $newxh $newyl $newyh
		  box
		 }\
		 else{\
	          ticksize -1 0 -1 0
                  # redo limits for log10 in x1,x2
		  set _newxl=LG($xl)
		  define newxl (_newxl)
		  set _newxh=LG($xh)
		  define newxh (_newxh)
		  set _newyl=LG($yl)
		  define newyl (_newyl)
		  set _newyh=LG($yh)
		  define newyh (_newyh)
		  limits  $newxl $newxh $newyl $newyh
		  box
		 }
                 relocate (15000 31500)
                 label RADIAL SCALE NOT EXACTLY CORRECT
	        }
                #
mybox1d 0       #
                #
                box
                #
mylines    0    #
                define LSTART ($LFINAL+1)
                define LFINAL ($LSTART+1)
                lines $LSTART $LFINAL
                #
filetest    1   # use fact that all non-typed files have more than 2 columns for 2nd line
                # only works back to but not including o11 for dumps, rest is ok
                da $1
                define LSTART (1)
                define LFINAL (2)
                lines $LSTART $LFINAL
                read !{test1 1 test2 2 test3 3}
                if(test3==1.001e+36){\
		 gpa 0
                 define LSTART (1)
                 define LFINAL (2)
                 lines $LSTART $LFINAL
                 read {_fileversion 1 _filetype 2}
                 define fileversion (_fileversion)
                 define filetype (_filetype)
		}\
		else{\
		 gpa 1
                 # put here which versions likely for old non-versioned files
		 if( ('$1'=='0_gparam.par')||('$1'=='0_igparam.par') ){\
                  # old version is likely 4
 		  define fileversion 4
		  define filetype $PTYPE
                 }
		 if( ('$1'=='0_grid1.par')||('$1'=='0_grid2.par')||('$1'=='0_gridact1.par')||('$1'=='0_gridact2.par')||('$1'=='0_igridact1.par')||('$1'=='0_igridact2.par') ){\
 		  define fileversion 2
		  define filetype $GRIDTYPE
                 }
                 set temptemp=substr('$1',0,4)
		 if((temptemp=='dump')||(temptemp=='idum')){\
 		  define fileversion 1
		  define filetype $DTYPE
                 }
		 if((temptemp=='adum')||(temptemp=='iadu')){\
 		  define fileversion 1
		  define filetype $ADTYPE
                 }
		 if((temptemp=='pdum')||(temptemp=='ipdu')){\
 		  define fileversion 1
		  define filetype $PDTYPE
                 }
		 if((temptemp=='floo')||(temptemp=='iflo')){\
 		  define fileversion 2
		  define filetype $FLTYPE
                 }
		 if((temptemp=='npdu')||(temptemp=='inpd')){\
		  define fileversion 1
		  define filetype $NPTYPE
                 }
		 if((temptemp=='cdum')||(temptemp=='icdu')){\
		  define fileversion 1
		  define filetype $CALCTYPE
                 }
		 if((temptemp=='fldum')||(temptemp=='ifldu')){\
		  define fileversion 1
		  define filetype $FIELDLINETYPE
                 }
		 if(('$1'=='0_avg2d.dat')||('$1'=='i0_avg2d.dat')){\
 		  define fileversion 1
		  define filetype $AVG2DTYPE
                 }
		 if('$1'=='0_avg1d.dat'){\
 		  define fileversion 1
		  define filetype $AVG1DTYPE
                 }
		 if('$1'=='0_ener.dat'){\
		  # ver=5  back to =n11 (inj/rad new)(n11 has no labels)
                  # ver=4  back to =n06 (inj new)
                  # ver=3  back to =o01
		  define fileversion 5
		  define filetype $ENERTYPE
                 }
		 if('$1'=='0_mode.dat'){\
		  define fileversion 1
		  define filetype $MODETYPE
                 }
		 if('$1'=='0_loss.dat'){\
                  # ver=5 back to o01
 		  define fileversion 5
		  define filetype $LOSSTYPE
                 }
		 if('$1'=='0_logsp.dat'){\
 		  define fileversion 1
		  define filetype $SPTYPE
                 }
		 if('$1'=='0_timescales.dat'){\
 		  define fileversion 1
		  define filetype $TSTYPE
                 }
		 if( ('$1'=='0_logdt.out.00')||('$1'=='0_logdt.out.01')||('$1'=='0_logdt.out.02')||('$1'=='0_logdt.out.03') ){\
 		  define fileversion 1
		  define filetype $LOGDTTYPE
                 }
		 if('$1'=='0_logstep.out'){\
 		  define fileversion 1
		  define filetype $STEPTYPE
                 }
		 if('$1'=='0_logperf.out'){\
		  define fileversion 3 # 2 is real, but 3 for now
		  define filetype $PERFTYPE
                 }
		 if((temptemp=='hst0')||(temptemp=='hst1')){\
 		  define fileversion 100
		  define filetype $ENERTYPE
                 }
                 define LSTART -1 define LFINAL 0
		}
                #
readpar     3   #
		readpar1 $1 $2 $3
		readpar2 $1 $2 $3
		readpar3 $1 $2 $3
		#
readpar1     3  #
                # rev=1 starts with o1,o7
                # rev start with o01  and goes to o11 (no alpha and no averages and no mass)
                if($fileversion==1){\
		 # rev probably defined by alphareal0, but no fallback
                 set _alphareal0=0,0,1
                 set _alphareal0[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
		 read {_rg 1 _cour 2 _cour2 3 _css 4 _gam 5 _wgam 6 _dt 7 _t 8 _tf 9}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _alphareal0 4 _nreal 5}
                 mylines
                 read {_GRAVC 1}
                 mylines
		 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_alphareal0[0])
		}
                # rev=2 starts with n01,o12, includes n,upto f12
                if($fileversion==2){\
                 # rev defined by extra var on rg line
                 set _numavg=0,0,1
                 set _numavg[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _cour 2 _cour2 3 _css 4 _alpha 5 _gam 6 _dt 7 _tstart 8 _tf 9 _tavgi 10 _tavgf 11 _numavg 12}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _alphareal0 4 _nreal 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
		 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_numavg[0])
		}
                # rev=3 starts with n27 (coolfact, alpha, etc. move around)
                if($fileversion==3){\
                 # rev defined by DTener
                 set _DTener=0,0,1
                 set _DTener[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _cour 2 _cour2 3 _css 4 coolfact 5 _gam 6 _dt 7 _tstart 8 _tf 9 _tavgi 10 _tavgf 11 _numavg 12}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _alphareal0 4 _nreal 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_DTener[0])
		}
                # ver=4 starts with run f12, includes g
                if($fileversion==4){\
                 # rev defined by extra var on rg line
                 set _numavg=0,0,1
                 set _numavg[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _rgp 2 _cour 3 _cour2 4 _css 5 coolfact 6 _gam 7 _dt 8 _tstart 9 _tf 10 _tavgi 11 _tavgf 12 _numavg 13}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _alphareal0 4 _nreal 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_numavg[0])
		}
                # ver=5 starts with a1
                # 5 is version as of Nov 1, 2000
                if($fileversion==5){\
                 # rev defined by extra line
                 set _vgz=0,0,1
                 set _vgz[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_vgz[0])
		}
                #
                # ver=6 starts with a8
                # 6 is version as of Nov 11, 2000
                if($fileversion==6){\
                 # rev defined by extra line
                 set _vgz=0,0,1
                 set _vgz[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 define parreadtest (_vgz[0])
		}
                #
                # ver=7 starts with mag field stuff
                # 7 is version as of Dec 10, 2000
                if($fileversion==7){\
                 # rev defined by extra lines
                 set _coord=0,0,1
                 set _coord[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_Sx 1 _Sy 2 _Sz 3 _Lx 4 _Ly 5 _Lz 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 mylines
                 read {_coord 1 _fullvec 2 _analoutput 3}
                 mylines
                 read {_trans 1 _transx1 2 _transrhox1 3 _transiex1 4 _transv1x1 5 _transv2x1 6 _transv3x1 7 _transmagx1 8 _transx2 9 _transrhox2 10 _transiex2 11 _transv1x2 12 _transv2x2 13 _transv3x2 14}
                 mylines
                 read {_press 1 _pressx1 2 _pressx2 3}
                 mylines
                 read {_mag 1 _transbzx 2 _transbzy 3 _stepmocct 4 _mocctvx1 5 _mocctvx2 6 _mocctbx1 7 _mocctbx2 8}
                 mylines
                 read {_iedo 1 _viscart 2 _viscreal 3 _vreal 4 _vischeat 5 _mdotin 6 _cool 7 _res 8 _advint 9 _kever 10}
                 mylines
                 read {_intix1 1 _intox1 2 _intix2 3 _intox2 4 _intix3 5 _intox3 6}
                 mylines
                 read {_nonunigridx1 1 _nonunigridx2 2 _nonunigridx3 3 _simplebc 4 _bcix1 5 _bcox1 6 _bcix2 7 _bcox2 8 _bcix3 9 _bcox3 10}
                 #
                 define parreadtest (_coord[0])
		}
readpar2     3  #
                #
                # ver=8 starts after mhdtori colloqium fli
                # 8 is version as of Feb 17, 2001
                if($fileversion==8){\
                 # rev defined by extra lines
                 set _coord=0,0,1
                 set _coord[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_x1in 1 _x2in 2 _x3in 3 _x1out 4 _x2out 5 _x3out 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 mylines
                 read {_coord 1 _fullvec 2 _analoutput 3}
                 mylines
                 read {_trans 1 _transx1 2 _transrhox1 3 _transiex1 4 _transv1x1 5 _transv2x1 6 _transv3x1 7 _transmagx1 8 _transx2 9 _transrhox2 10 _transiex2 11 _transv1x2 12 _transv2x2 13 _transv3x2 14}
                 mylines
                 read {_press 1 _pressx1 2 _pressx2 3}
                 mylines
                 read {_mag 1 _transbzx 2 _transbzy 3 _stepmocct 4 _mocctvx1 5 _mocctvx2 6 _mocctbx1 7 _mocctbx2 8}
                 mylines
                 read {_iedo 1 _viscart 2 _viscreal 3 _vreal 4 _vischeat 5 _mdotin 6 _cool 7 _res 8 _advint 9 _kever 10}
                 mylines
                 read {_intix1 1 _intox1 2 _intix2 3 _intox2 4 _intix3 5 _intox3 6}
                 mylines
                 read {_nonunigridx1 1 _nonunigridx2 2 _nonunigridx3 3 _simplebc 4 _bcix1 5 _bcox1 6 _bcix2 7 _bcox2 8 _bcix3 9 _bcox3 10}
                 #
                 set _Sx=_x1in
                 set _Sy=_x2in
                 set _Sz=_x3in
                 set _Lx=(_x1out-_x1in)
                 set _Ly=(_x2out-_x2in)
                 set _Lz=(_x3out-_x3in)
                 define parreadtest (_coord[0])
		}
                # ver=9 starts after gravitomagnetic tori
                # 9 is version as of March 12, 2001
                if($fileversion==9){\
                 # rev defined by extra lines
                 set _coord=0,0,1
                 set _coord[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_x1in 1 _x2in 2 _x3in 3 _x1out 4 _x2out 5 _x3out 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2 _invsol2 3 _blackholejz 4}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 mylines
                 read {_coord 1 _fullvec 2 _analoutput 3 _DYNAMICMM 4}
                 mylines
                 read {_trans 1 _transx1 2 _transrhox1 3 _transiex1 4 _transv1x1 5 _transv2x1 6 _transv3x1 7 _transmagx1 8 _transx2 9 _transrhox2 10 _transiex2 11 _transv1x2 12 _transv2x2 13 _transv3x2 14 _transvmagx3 15}
                 mylines
                 read {_press 1 _pressx1 2 _pressx2 3}
                 mylines
                 read {_mag 1 _transbzx 2 _transbzy 3 _stepmocct 4 _mocctvx1 5 _mocctvx2 6 _mocctbx1 7 _mocctbx2 8}
                 mylines
                 read {_iedo 1 _viscart 2 _viscreal 3 _vreal 4 _vischeat 5 _mdotin 6 _cool 7 _resreal 8 _rreal 9 _resheat 10 _advint 11 _kever 12}
                 mylines
                 read {_intix1 1 _intox1 2 _intix2 3 _intox2 4 _intix3 5 _intox3 6}
                 mylines
                 read {_nonunigridx1 1 _nonunigridx2 2 _nonunigridx3 3 _simplebc 4 _bcix1 5 _bcox1 6 _bcix2 7 _bcox2 8 _bcix3 9 _bcox3 10}
                 #
                 set _Sx=_x1in
                 set _Sy=_x2in
                 set _Sz=_x3in
                 set _Lx=(_x1out-_x1in)
                 set _Ly=(_x2out-_x2in)
                 set _Lz=(_x3out-_x3in)
                 define parreadtest (_coord[0])
		}
		#
readpar3 3      #
		# ver=10 starts after a bit of 3D implementation(before physics)
                # 10 is version as of April 3, 2001
                if($fileversion==10){\
                 # rev defined by extra lines
                 set _coord=0,0,1
                 set _coord[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_x1in 1 _x2in 2 _x3in 3 _x1out 4 _x2out 5 _x3out 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2 _invsol2 3 _blackholejz 4}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8 _DTfld 9}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 mylines
                 read {_coord 1 _fullvec 2 _analoutput 3 _DYNAMICMM 4}
                 mylines
                 read {_trans 1 _transx1 2 _transrhox1 3 _transiex1 4 _transv1x1 5 _transv2x1 6 _transv3x1 7 _transmagx1 8 _transx2 9 _transrhox2 10 _transiex2 11 _transv1x2 12 _transv2x2 13 _transv3x2 14 _transmagx2 15 _transx3 16 _transrhox3 17 _transiex3 18 _transv1x3 19 _transv2x3 20 _transv3x3 21}
                 mylines
                 read {_press 1 _pressx1 2 _pressx2 3 _pressx3 4}
                 mylines
                 read {_mag 1 _transbzx 2 _transbzy 3 _stepmocct 4 _mocctvx1 5 _mocctvx2 6 _mocctvx3 7 _mocctbx1 8 _mocctbx2 9 _mocctbx3 10}
                 mylines
                 read {_iedo 1 _viscart 2 _viscreal 3 _vreal 4 _vischeat 5 _mdotin 6 _cool 7 _resreal 8 _rreal 9 _resheat 10 _advint 11 _kever 12}
                 mylines
                 read {_intix1 1 _intox1 2 _intix2 3 _intox2 4 _intix3 5 _intox3 6}
                 mylines
                 read {_nonunigridx1 1 _nonunigridx2 2 _nonunigridx3 3 _simplebc 4 _bcix1 5 _bcox1 6 _bcix2 7 _bcox2 8 _bcix3 9 _bcox3 10}
                 #
                 set _Sx=_x1in
                 set _Sy=_x2in
                 set _Sz=_x3in
                 set _Lx=(_x1out-_x1in)
                 set _Ly=(_x2out-_x2in)
                 set _Lz=(_x3out-_x3in)
                 define parreadtest (_coord[0])
		}
		#
		# ver=11 starts with DTmode
                # 11 is version as of July 13, 2001
                if($fileversion==11){\
                 # rev defined by extra lines
                 set _coord=0,0,1
                 set _coord[0]=-100
                 mylines
                 read {_nx 1 _ny 2 _nz 3}
                 mylines
		 read {_x1in 1 _x2in 2 _x3in 3 _x1out 4 _x2out 5 _x3out 6}
                 mylines
                 read {_rg 1 _rgp 2 _css 3 coolfact 4 _gam 5 _alphareal0 6 _nreal 7}
                 mylines
                 read {_nuvnr 1 _nul 2 _nuten 3 _cour 4 _cour2 5}
                 mylines
                 read {_GRAVC 1 _MASS 2 _invsol2 3 _blackholejz 4}
                 mylines
		 read {_tstart 1 _tf 2 _tavgi 3 _tavgf 4 _numavg 5 _timagescale 6}
                 mylines
                 read {_DTl 1 _DTd 2 _DTi 3 _DTloss 4 _DTfloor 5 _DTtimestep 6 _DTpd 7 _DTener 8 _DTfld 9 _DTmode 10}
                 mylines
                 read {_res 1 _nush 2}
                 mylines
                 read {_vgx 1 _vgy 2 _vgz 3}
                 mylines
                 read {_coord 1 _fullvec 2 _analoutput 3 _DYNAMICMM 4}
                 mylines
                 read {_trans 1 _transx1 2 _transrhox1 3 _transiex1 4 _transv1x1 5 _transv2x1 6 _transv3x1 7 _transmagx1 8 _transx2 9 _transrhox2 10 _transiex2 11 _transv1x2 12 _transv2x2 13 _transv3x2 14 _transmagx2 15 _transx3 16 _transrhox3 17 _transiex3 18 _transv1x3 19 _transv2x3 20 _transv3x3 21}
                 mylines
                 read {_press 1 _pressx1 2 _pressx2 3 _pressx3 4}
                 mylines
                 read {_mag 1 _transbzx 2 _transbzy 3 _stepmocct 4 _mocctvx1 5 _mocctvx2 6 _mocctvx3 7 _mocctbx1 8 _mocctbx2 9 _mocctbx3 10}
                 mylines
                 read {_iedo 1 _viscart 2 _viscreal 3 _vreal 4 _vischeat 5 _mdotin 6 _cool 7 _resreal 8 _rreal 9 _resheat 10 _advint 11 _kever 12}
                 mylines
                 read {_intix1 1 _intox1 2 _intix2 3 _intox2 4 _intix3 5 _intox3 6}
                 mylines
                 read {_nonunigridx1 1 _nonunigridx2 2 _nonunigridx3 3 _simplebc 4 _bcix1 5 _bcox1 6 _bcix2 7 _bcox2 8 _bcix3 9 _bcox3 10}
                 #
                 set _Sx=_x1in
                 set _Sy=_x2in
                 set _Sz=_x3in
                 set _Lx=(_x1out-_x1in)
                 set _Ly=(_x2out-_x2in)
                 set _Lz=(_x3out-_x3in)
                 define parreadtest (_coord[0])
		}
		#
                #
setvisc    0    #
                define fullvec 0
                define npdone 1
                set mag=0
                set _mag=0
                #
		#
rdbasic 3       #
		rdbasic1 $1 $2 $3
		rdbasic2 $1 $2 $3
		rdbasic3 $1 $2 $3 # the grid itself
		rdbasic4 $1 $2 $3
rdbasic1 3      #
                # [0/1][0/1]
                # [0][]->non interp [1][]->interp
                # [][0]->active grid [][1]->total grid
                # [][][n] number of cpu, or -1 for no multiple cpu
                # assume by default that does not exist unless specified after having done pp
                if($?npdone == 0){\
                  define npdone (0)
                }
                define rdbasicloaded (1)
                # number of files to skip for animation sequences
                define ANIMSKIP (1)
                set it=sprintf('%04d',$3)
                define cpunum (it)
                if($1==0){\
                 define filepar "0_gparam.par"
		 define interp (0)
		}\
		else{\
                 define filepar "0_igparam.par"
		 define interp (1)
		}
                if($2==0){\
                 define totalgrid (0)
		}\
		else{\
		 define totalgrid (1)
		}
                filetest $filepar
                readpar $1 $2 $3
                # check on 0_gparam.par read and redo if not good
                if($?parreadtest==1){\
                 if($parreadtest>-99){\
                  define temptemptemp (0)
                 }\
                 else{\
                  filetest $filepar
                  echo trying par fileversion 5
                  define fileversion 5
                  readpar $1 $2 $3
                 }
                 if($parreadtest>-99){\
                  define temptemptemp (0)
                 }\
                 else{\
                  filetest $filepar
                  echo trying par fileversion 4
                  define fileversion 4
                  readpar $1 $2 $3
                 }
                 if($parreadtest>-99){\
                  define temptemptemp (0)
                 }\
                 else{\
                  filetest $filepar
                  echo trying par fileversion 3
                  define fileversion 3
                  readpar $1 $2 $3
                 }
                 if($parreadtest>-99){\
                  define temptemptemp (0)
                 }\
                 else{\
                  filetest $filepar
                  echo trying par fileversion 2
                  define fileversion 2
                  readpar $1 $2 $3
                 }
                 if($parreadtest>-99){\
                  define temptemptemp (0)
                 }\
                 else{\
                  filetest $filepar
                  echo trying par fileversion 1
                  define fileversion 1
                  readpar $1 $2 $3
                 }
                }
		#
rdbasic2 3      #		
                #
                # define only needed vars
                define csgam1 (_css)
                define alphareal0 (_alphareal0)
                if($2==1){\
		       if(_nx>1){ define nx (_nx+4) } else { define nx (_nx) }
		       if(_ny>1){ define ny (_ny+4) } else { define ny (_ny) }
		       if(_nz>1){ define nz (_nz+4) } else { define nz (_nz) }
	        }\
                else{\
		       define nx (_nx)
		       define ny (_ny)
		       define nz (_nz)
		       }
                define gam (_gam)
                define fullvec (_fullvec)
                define coord (_coord)
                if(ABS($gam-1.0)<1.E-6){\
					  set wgam=0
					  set wgam1=1
					  set cs=0,$nx*$ny-1
					  set cs=$csgam1*cs/cs
		}\
		else{\
		       set wgam=1
		       set wgam1=0
		}
                if(ABS($gam-5.0/3.0)<1.E-6){\
					 set wgam53=1
		}\
		else{\
		       set wgam53=0
		}
                #
                #
rdbasic3 3      #		
                # now get geometry on active grid
                if($interp==0){\
                         if($totalgrid==0){\
				     if($cpunum<0){\
                                  rd 0_gridact1.par
                                  rd 0_gridact2.par 2
				     }\
				     else{\
                                  rd 0_gridact1.par.$cpunum
                                  rd 0_gridact2.par.$cpunum 2
					    }\
                         }\
                         else{\
				if($cpunum<0){\
					   rd 0_grid1.par
					   rd 0_grid2.par 2
				 }\
				    else{\
					   rd 0_grid1.par.$cpunum
					   rd 0_grid2.par.$cpunum 2
					   }\
			 }\
		}\
		else{\
                 if($totalgrid==0){\
				  if($cpunum<0){\
                                  rd 0_igridact1.par
                                  rd 0_igridact2.par 2
				     }\
				     else{\
                                  rd 0_igridact1.par.$cpunum
                                  rd 0_igridact2.par.$cpunum 2
					    }\
                         }\
                         else{\
				if($cpunum<0){\
					   rd 0_igridact1.par
					   rd 0_igridact2.par 2
				 }\
				    else{\
					   rd 0_igridact1.par.$cpunum
					   rd 0_igridact2.par.$cpunum 2
					   }\
			 }\
		}		
                #
rdbasic4 3	#	
                # define derivative vars
                # for full grid require data that global param file does not have
                if($2==1){\
		 if($nx>1){ define Lx (x12[$nx-1]-x12[0]) }\
		 else{ define Lx (x12[0])}
		 if($nx>1){ define Ly (x22[$nx*$ny-1]-x22[0]) }\
		 else{ define Ly (x22[0])}
		 if($nx>1){ define Lz (x3[$nx*$ny*$nz-1]-x3[0]) }\
		 else{ define Lz (x32[0])}
                 # 
		 define Sx (x12[0])
		 define Sy (x22[0]) 
		 define Sz (x32[0]) # 3D
		 #define Sz (x3[0])      # 2D
                }\
                else{\
                define Lx (_Lx) 
                define Ly (_Ly)
                define Lz (_Lz)
                define Sx (_Sx)
                define Sy (_Sy)
                define Sz (_Sz)
		       }
                define dx ($Lx/$nx)
		define dy ($Ly/$ny)
		define dz ($Lz/$nz)
                #
rdnumd 0        #
                da 0_numdumps.dat
                lines 1 2
                read {_NUMDUMPS 1}
                define NUMDUMPS (_NUMDUMPS)
		da 0_numfldumps.dat
                lines 1 2
                read {_NUMFLDUMPS 1}
                define NUMFLDUMPS (_NUMFLDUMPS)
                da 0_numpdumps.dat
                lines 1 2
                read {_NUMPDUMPS 1}
                define NUMPDUMPS (_NUMPDUMPS)
                da 0_numadumps.dat
                lines 1 2
                read {_NUMADUMPS 1}
                define NUMADUMPS (_NUMADUMPS)
                da 0_numnpdumps.dat
                lines 1 2
                read {_NUMNPDUMPS 1}
                define NUMNPDUMPS (_NUMNPDUMPS)
                da 0_numfloordumps.dat
                lines 1 2
                read {_NUMFLOORDUMPS 1}
                define NUMFLOORDUMPS (_NUMFLOORDUMPS)
		da ./i/0_numimages.dat
                lines 1 2
                read {_NUMIMAGES 1}
                define NUMIMAGES (_NUMIMAGES)
                echo filenumber=(0..NUM-1)
                echo Number of dumps: $NUMDUMPS
                echo Number of npdumps: $NUMNPDUMPS
                echo Number of pdumps: $NUMPDUMPS
                echo Number of adumps: $NUMADUMPS
                echo Number of floordumps: $NUMFLOORDUMPS
		echo Number of images: $NUMIMAGES
		echo Number of fldumps: $NUMFLDUMPS
myrd   12       # (checks filename, loads if name, does not if name is 0)
		set tempit=WHATIS($1)
		if(tempit==0){\
                  define temptemptemp (1)
                }\
                else{\
                 if($?2 == 0) {
              	  rd $1
		 }\
		 else{\
		  rd $1 $2
		 }
                }
                #
rd	12	# read macro for all data
                # e.g. rd 0_loss.dat  e.g. rd adump0000.dat 2
                if($?finaldraft==0){ rdraft }
                define failuremode (0)
                #
                if($?2 == 1){\
		 if($2==-1){\
		  define temptemptemp (0)
                  # just do not change anything!
                  # needed since otherwise rd np$1 inside would switch definitions
                 }
		 if($2==-2){\
 		  define exttype (0)
                  define ext " "
                  define extx x
                  define exty y
                  define extz z
                 }
                 if(($2!=-1)&&($2!=-2)){\
		  define exttype (1)
		  define ext $2
		  define extx $2x
                  define exty $2y
                  define extz $2z
		 }
                }\
                else{\
		 define exttype (0)
                 define ext " "
                 define extx x
                 define exty y
                 define extz z
                }
                rdintro $1
		if(!($failuremode)){\
                 rdreads $1
                 if($filetype==$ENERTYPE){\
                  # check on 0_ener.dat read and redo if not good
                  if($?enerreadtest==1){\
                   if($enerreadtest>-99){\
                    define temptemptemp (0)
                   }\
                   else{\
                    echo trying ener fileversion 4
                    rdintro $1
                    define fileversion 4
                    rdreads $1
                   }
                  }
                  if($?enerreadtest==1){\
                   if($enerreadtest>-99){\
                    define temptemptemp (0)
                   }\
                   else{\
                    echo trying ener fileversion 3
                    rdintro $1
                    define fileversion 3
                    rdreads $1
                   }
                  }
                 }
                 if($filetype==$NPTYPE){\
 		  if($npdumpreadtest<-99){\
                   echo trying npdump fileversion 0
                   rdintro $1
                   define fileversion 0
		   rdreads $1
		  }
		 }
                 #
                 if( ($filetype==$DTYPE)&&($npdone) ){\
                  # generally read in npdump when dumps are read
	 	  define oldfileversion2 $fileversion
		  define oldfiletype2 $filetype
	 	  rd np$1 -1
                  # return to normal filetype after done
                  define fileversion $oldfileversion2
                  define filetype $oldfiletype2
		 }
                 # assume dump gets the calc for npdump
                 if($filetype!=$NPTYPE){\
                  if($DOCALCS){\
                   rdcalcs1 $1
                   rdcalcs2 $1
                  }
		 }
		}
                #
rdbondi   0     # (must load rdbasic still first for gam)(why the fuck is this if statement not same as others in back slashes!)
                da 0_analdata2.dat
                read {rad 1 rho 2 ie 3 gravpot 4 vr 5 vtheta 6 vphi 7 br 8 btheta 9 bphi 10}
                #
                if(wgam1==1){
		  set cs=0,($nx+4)*$ny-1
		  do ii=0,($nx+4)*$ny-1,1 {
		    set cs[$ii]=$csgam1
		  }
			       set cs2=cs*cs
			       set Be=0.5*vr*vr+cs*cs*LN(rho)+gravpot
		}\
		else{
		       set cs2=$gam*($gam-1)*ie/rho
                        set cs=sqrt(cs2)

		       set Be=0.5*vr*vr+cs*cs/($gam-1)+gravpot                  
		}
                set Machr=vr/cs
		set Mdot=4*3.14159*rad*rad*rho*vr
		set p=($gam-1.0)*ie
		set entropy=p/rho**($gam)
                #
magcall         #
		set mflux=(r*vx* x1*x1*sin(x2)*dx2)
		set keflux=(r*vx*0.5*(vx**2+vy**2+vz**2)*x1*x1*sin(x2)*dx2)
                set hflux = (vx*($gam*en)*x1*x1*sin(x2)*dx2)
		set beflux=((bx**2+by**2+bz**2)*vx-(bx*vx+by*vy+bz*vz)*bx)*x1*x1*sin(x2)*dx2
		set peflux=(r*vx*pot*x1*x1*sin(x2)*dx2)
		set eflux = keflux+hflux+beflux+peflux
		set v1flux=(x1*x1*sin(x2)*dx2)*(r*vx*vx+p-bx*bx+0.5*(bx**2+by**2+bz**2))
		set v3fluxrey=(r*vx*vz* x1*x1*sin(x2)*dx2 * x1*sin(x2))
		set v3fluxmag=-(bx*bz* x1*x1*sin(x2)*dx2 * x1*sin(x2))
                set v3flux = v3fluxrey+v3fluxmag
		set b1flux2=x1*sin(x2)*(vx*by-vy*bx)*dx1
		set b2flux1=-x1*sin(x2)*(vx*by-vy*bx)*dx2
		set b3flux1=x1*(vx*bz-vz*bx)*dx2
		set b3flux2=-(vy*bz-vz*vy)*dx1
                # magbondi
                define mag (1) define npdone (0) define coord (1)
                #set MAGK = 0.3317559754612477089752102542397933695730641977564196
                #set MAGF = 8.4822847861354036832817652116918313741194889910534187E-10
                #set MAGOMEGA = 0.000044721359549995793928183473374625524708812367192210704
                #set MAGPHI = 0.0095086263442549441567086161486063491924189885097233
                #set xs = 0.7770330780030363194074308952074505
                #set ys = 1.940544269119426993709021901238330
                #set xf = 1.302391299892080014807550863286971
                #set yf = 0.5139371598659040285268997762736311
                # set En = 1.738429467866434807018809306133664 // dimensionless form
                #set MAGEN = 0.003476858935732869614037618612267327
                #set beta = 0.5755932415448330480108551469612932
                set MAGRA = 500.0
                set RHORA = 1E-13
                set gam=1.2
                set GM = 1
		set MAGTHETA=(0.5) # // dimenless
                set MAGomega=(.25) # // dimenless
		set  SPFAST=(1.302391299892080014807550863286971) # // y=0.5139371598659040285268997762736311
                set SPALF=(1.0) #// y=1.0
                set SPSLOW=(0.7770330780030363194074308952074505) #// y=1.940544269119426993709021901238330
                set MAGBETA=(0.5755932415448330480108551469612932) #// dimenless
                set MAGE=(1.738429467866434807018809306133664) #// dimenless:
		set MAGK=(RHORA**(1.0-gam)*MAGTHETA/(gam*MAGRA))
                set MAGF=(RHORA*SQRT(MAGBETA*GM*MAGRA**(3.0)))
                set MAGOMEGA=(SQRT(GM*MAGomega/MAGRA**(3.0)))
                # #define MAGPHI (sqrt(4.0*M_PI*MAGBETA*GM*pow(MAGRA,3.0)*RHORA))
                set MAGPHI=(SQRT(MAGBETA*GM*MAGRA**(3.0)*RHORA))
                set VELRA=(MAGF/(MAGRA*MAGRA*RHORA))
                set MAGENERGY=(MAGE*GM/MAGRA)
                # mag bondi equations for check, should all be 0
                rdbondi
                set p=($gam-1.0)*ie
                set diff1=p-MAGK*rho**($gam)
                set diff2=MAGF-rho*vr*rad*rad
                set diff3=MAGPHI-br*rad*rad
                set diff4=vr*bphi-br*(vphi-MAGOMEGA*rad)
                set diff5=MAGOMEGA*MAGRA*MAGRA-rad*(vphi-br*bphi/(rho*vr))
                set diff6=0.5*(vr**2+(vphi-MAGOMEGA*rad)**2)+$gam/($gam-1)*p/rho-GM/rad-0.5*MAGOMEGA*MAGOMEGA*rad*rad-MAGENERGY
                #set ftemp=rad*(MAGPHI*MAGPHI*rho-MAGF*MAGF)
                #set vphinum=MAGOMEGA*(MAGPHI*MAGPHI*rad*rad*rho-MAGF*MAGF*MAGRA*MAGRA)
                set energy=1/2*rho*(vr**2+vtheta**2+vphi**2)+ie+1/(2)*(br**2+btheta**2+bphi**2)+rho*gravpot
		set senergy=1/2*(vr**2+vtheta**2+vphi**2)+ie/rho+1/(2*rho)*(br**2+btheta**2+bphi**2)+rho*gravpot
                #
rdintro 1       #
		da $1
                filetest $1
                if(($filetype==$FIELDLINETYPE)||($filetype==$CALCTYPE)||($filetype==$DTYPE)||($filetype==$PDTYPE)||($filetype==$ADTYPE)||($filetype==$FLTYPE)||($filetype==$NPTYPE)||($filetype==$AVG2DTYPE)||($filetype==$AVG1DTYPE)){\
                 define LSTART ($LFINAL+1)
                 define LFINAL ($LSTART+1)
                 lines $LSTART $LFINAL
 	 	 read {_time 1 _SAMPLE 2 _ALLZONEC 3}
                 define time (_time)
                 define SAMPLE (_SAMPLE)
                 define ALLZONEC (_ALLZONEC)
                 define LSTART ($LFINAL+1)
                 define LFINAL ($LSTART+1)
		 lines $LSTART $LFINAL
  		 read {_N1 1 _N2 2 _N3 3}
                 define dnx (_N1)
                 define dny (_N2)
                 define dnz (_N3)
		 if($?rdbasicloaded==1){\
		  if( ($dnx!=$nx)||($dny!=$ny)||($dnz!=$nz) ){\
		   echo dump grid different than grid size expects, load rdbasic?
		   define failuremode (1)
		   return
		  }
		 }\
		 else{\
                  define oldLSTART $LSTART
                  define oldLFINAL $LFINAL
		  define oldexttype $exttype
		  define oldext "$!ext"
		  define oldextx "$!extx"
                  define oldexty "$!exty"
                  define oldextz "$!extz"
		  define oldfileversion $fileversion
		  define oldfiletype $filetype
                  rdbasic 0 0 -1 # load typical params
                  define LSTART $oldLSTART
                  define LFINAL $oldLFINAL
		  define exttype $oldexttype
		  define ext "$!oldext"
		  define extx "$!oldextx"
                  define exty "$!oldexty"
                  define extz "$!oldextz"
                  define fileversion $oldfileversion
                  define filetype $oldfiletype
		 }
                }
                #
rdreads 1       #
                rdreads1 $1
                rdreads2 $1
                rdreads3 $1
		rdreads32 $1
                rdreads4 $1
                #
rdreads1 1      #
                da $1   # in case other reads have occured so far
                # generally good
                define LSTART ($LFINAL+1)
                define LFINAL 10000000
		lines $LSTART $LFINAL
                #echo thelines $LSTART $LFINAL
                #
                if(($filetype==$DTYPE)||($filetype==$ADTYPE)||($filetype==$PDTYPE)){\
		 if($fullvec){\
		  read {r$!!ext 1 en$!!ext 2 pot$!!ext 3 v$!!extx 4 v$!!exty 5 v$!!extz 6 b$!!extx 7 b$!!exty 8 b$!!extz 9}
		 }\
		 else{\
		  read {r$!!ext 1 en$!!ext 2 pot$!!ext 3 v$!!extx 4 v$!!exty 5 v$!!extz 6}
		 }
                }
                if($filetype==$CALCTYPE){\
		 read {LR$!!extx 1 LR$!!exty 2 LR$!!extz 3 LV$!!extx 4 LV$!!exty 5 LV$!!extz 6 ER$!!extx 7 ER$!!exty 8 ER$!!extz 9 EV$!!extx 10 EV$!!exty 11 EV$!!extz 12}
                }
		if($filetype==$FIELDLINETYPE){\
		 read {phib$!!extz 1}
                }
                if($filetype==$FLTYPE){\
                 if($fileversion==2){\
   		  read {r$!!ext 1 en$!!ext 2 pot$!!ext 3 ke$!!ext 4 v$!!extx 5 v$!!exty 6 v$!!extz 7}
                 }
                 if($fileversion==1){\
   		  read {r$!!ext 1 en$!!ext 2 pot$!!ext 3 v$!!extx 4 v$!!exty 5 v$!!extz 6}
                 }
                }
                if($filetype==$NPTYPE){\
                 set nuvisc$!!ext=0,0,1
                 set nuvisc$!!ext[0]=-100
                 if($fileversion==2){\
		  read {sig11$!!ext 1 sig12$!!ext 2 sig13$!!ext 3 sig22$!!ext 4 sig23$!!ext 5 sig33$!!ext 6 nuvisc$!!ext 7}
                  set sig21$!!ext=sig12$!!ext
                  set sig31$!!ext=sig13$!!ext
                  set sig32$!!ext=sig23$!!ext
                 }
                 if($fileversion==1){\
		  read {sig11$!!ext 1 sig12$!!ext 2 sig13$!!ext 3 sig21$!!ext 4 sig22$!!ext 5 sig23$!!ext 6 sig31$!!ext 7 sig32$!!ext 8 sig33$!!ext 9 nuvisc$!!ext 10}
                 }
                 if($fileversion==0){\
 		  read {sig11$!!ext 1 sig12$!!ext 2 sig13$!!ext 3 sig21$!!ext 4 sig22$!!ext 5 sig23$!!ext 6 sig31$!!ext 7 sig32$!!ext 8 sig33$!!ext 9}
                 }
                 define npdumpreadtest (nuvisc$!!ext[0])
                }
                if($filetype==$AVG2DTYPE){\
                 if($fileversion==1){\
                  read {r$!!ext 1 en$!!ext 2 be2d$!!ext 3 csq2d$!!ext 4 e2d$!!ext 5 v$!!extx 6 v$!!exty 7 v$!!extz 8}
                 }
                 if($fileversion==2){\
		  read {r$!!ext 1 en$!!ext 2 be2d$!!ext 3 csq2d$!!ext 4 e2d$!!ext 5 v$!!extx 6 v$!!exty 7 v$!!extz 8 sig11$!!ext 9 sig12$!!ext 10 sig13$!!ext 11 sig22$!!ext 12 sig23$!!ext 13 sig33$!!ext 14 nuvisc$!!ext 15}
                  set sig21$!!ext=sig12$!!ext
                  set sig31$!!ext=sig13$!!ext
                  set sig32$!!ext=sig23$!!ext
                 }
                }
                if($filetype==$AVG1DTYPE){\
                 if($fileversion==1){\
  		  read {r1d1$!!ext 1 en1d1$!!ext 2 be1d1$!!ext 3 csq1d1$!!ext 4 s1d1$!!ext 5 v1d1$!!extx 6 v1d1$!!exty 7 v1d1$!!extz 8\
		        r1d2$!!ext 9 en1d2$!!ext 10 be1d2$!!ext 11 csq1d2$!!ext 12 s1d2$!!ext 13 v1d2$!!extx 14 v1d2$!!exty 15 v1d2$!!extz 16}
                 }
                 if($fileversion==2){\
  	          read {r1d1$!!ext 1 en1d1$!!ext 2 be1d1$!!ext 3 csq1d1$!!ext 4 s1d1$!!ext 5 v1d1$!!extx 6 v1d1$!!exty 7 v1d1$!!extz 8 sig111d1$!!ext 9 sig121d1$!!ext 10 sig131d1$!!ext 11 sig221d1$!!ext 12 sig231d1$!!ext 13 sig331d1$!!ext 14 nuvisc1d1$!!ext 15\
	       	        r1d2$!!ext 16 en1d2$!!ext 17 be1d2$!!ext 18 csq1d2$!!ext 19 s1d2$!!ext 20 v1d2$!!extx 21 v1d2$!!exty 22 v1d2$!!extz 23 sig111d2$!!ext 24 sig121d2$!!ext 25 sig131d2$!!ext 26 sig221d2$!!ext 27 sig231d2$!!ext 28 sig331d2$!!ext 29 nuvisc1d2$!!ext 30}
	         }
                  echo make sure you read in normal dump for potential
  		  if($AVG1DWHICH==1){\
                   set r$!!ext=r1d1$!!ext
                   set en$!!ext=en1d1$!!ext
                   set v$!!extx=v1d1$!!extx
                   set v$!!exty=v1d1$!!exty
                   set v$!!extz=v1d1$!!extz
                   set sig11$!!ext=sig131d1$!!ext
                   set sig12$!!ext=sig121d1$!!ext
                   set sig13$!!ext=sig131d1$!!ext
                   set sig22$!!ext=sig221d1$!!ext
                   set sig23$!!ext=sig231d1$!!ext
                   set sig33$!!ext=sig331d1$!!ext
	          }
  	          if($AVG1DWHICH==2){\
                   set r$!!ext=r1d2$!!ext
                   set en$!!ext=en1d2$!!ext
                   set v$!!extx=v1d2$!!extx
                   set v$!!exty=v1d2$!!exty
                   set v$!!extz=v1d2$!!extz
                   set sig11$!!ext=sig131d2$!!ext
                   set sig12$!!ext=sig121d2$!!ext
                   set sig13$!!ext=sig131d2$!!ext
                   set sig22$!!ext=sig221d2$!!ext
                   set sig23$!!ext=sig231d2$!!ext
                   set sig33$!!ext=sig331d2$!!ext
	          }
                }
                if($filetype==$GRIDTYPE){\
                 if($fileversion==2){\
                   read {gr$!!ext 1 k$!!ext 2 j$!!ext 3 i$!!ext 4 dx1$!!ext 5 dx2$!!ext 6 dx3$!!ext 7 x1$!!ext 8 x2$!!ext 9 x3$!!ext 10 g1$!!ext 11 dg1$!!ext 12 g2$!!ext 13 dg2$!!ext 14\
	 	         g3$!!ext 15 dg3$!!ext 16 g4$!!ext 17 dg4$!!ext 18 cot$!!ext 19 dvl1$!!ext 20 dvl2$!!ext 21 dvl3$!!ext 22\
		         bcstyp1$!!ext 23 bcsdim1$!!ext 24 bcsdir1$!!ext 25 bcstyp2$!!ext 26 bcsdim2$!!ext 27 bcsdir2$!!ext 28 bcstyp3$!!ext 29 bcsdim3$!!ext 30 bcsdir3$!!ext 31\
		         bcvtyp1$!!ext 32 bcvdim1$!!ext 33 bcvdir1$!!ext 34 bcvtyp1$!!ext 35 bcvdim1$!!ext 36 bcvdir1$!!ext 37}
                   set xc$!!ext=x1$!!ext*sin(x2$!!ext)
                   set zc$!!ext=x1$!!ext*cos(x2$!!ext)
                 }
		 if($fileversion==3){\
                   read {gr$!!ext 1 k$!!ext 2 j$!!ext 3 i$!!ext 4 dx1$!!ext 5 dx2$!!ext 6 dx3$!!ext 7 x1$!!ext 8 x2$!!ext 9 x3$!!ext 10 g1$!!ext 11 dg1$!!ext 12 g2$!!ext 13 dg2$!!ext 14\
	 	         g3$!!ext 15 dg3$!!ext 16 g4$!!ext 17 dg4$!!ext 18 dvl1$!!ext 19 dvl2$!!ext 20 dvl3$!!ext 21\
		         bcstyp1$!!ext 22 bcsdim1$!!ext 23 bcsdir1$!!ext 24 bcstyp2$!!ext 25 bcsdim2$!!ext 26 bcsdir2$!!ext 27 bcstyp3$!!ext 28 bcsdim3$!!ext 29 bcsdir3$!!ext 30\
		         bcvtyp1$!!ext 31 bcvdim1$!!ext 32 bcvdir1$!!ext 33 bcvtyp1$!!ext 34 bcvdim1$!!ext 35 bcvdir1$!!ext 36}
                   set xc$!!ext=x1$!!ext*sin(x2$!!ext)
                   set zc$!!ext=x1$!!ext*cos(x2$!!ext)
                 }
                }
                #
rdreads2  1     #
                if($filetype==$ENERTYPE){\
                 if($fileversion==6){\
                  set mrad$!!ext=0,0,1
                  set mrad$!!ext[0]=-100
		  if($fullvec){\
		   read {t$!!ext 1\
                   etot$!!ext 2 etotdel$!!ext 3 etotblost$!!ext 4 etotfladd$!!ext 5 etotinj$!!ext 6 etotrad$!!ext  7 etotdiff$!!ext  8\
		   m$!!ext    9 mdel$!!ext   10 mblost$!!ext   11 mfladd$!!ext   12 minj$!!ext   13 mrad$!!ext    14 mdiff$!!ext    15\
                   ie$!!ext  16 iedel$!!ext  17 ieblost$!!ext  18 iefladd$!!ext  19 ieinj$!!ext  20 ierad$!!ext   21 iediff$!!ext   22\
                   pe$!!ext 23 pedel$!!ext 24 peblost$!!ext 25 pefladd$!!ext 26 peinj$!!ext 27 perad$!!ext  28 pediff$!!ext  29\
		   ke$!!ext  30 kedel$!!ext  31 keblost$!!ext  32 kefladd$!!ext  33 keinj$!!ext  34 kerad$!!ext   35 kediff$!!ext   36\
                   mx1$!!ext 37 mx1del$!!ext 38 mx1blost$!!ext 39 mx1fladd$!!ext 40 mx1inj$!!ext 41 mx1rad$!!ext  42 mx1diff$!!ext  43\
                   mx2$!!ext 44 mx2del$!!ext 45 mx2blost$!!ext 46 mx2fladd$!!ext 47 mx2inj$!!ext 48 mx2rad$!!ext  49 mx2diff$!!ext  50\
		   mx3$!!ext 51 mx3del$!!ext 52 mx3blost$!!ext 53 mx3fladd$!!ext 54 mx3inj$!!ext 55 mx3rad$!!ext  56 mx3diff$!!ext  57\
                   be$!!ext  58 bedel$!!ext  59 beblost$!!ext  60 befladd$!!ext  61 beinj$!!ext  62 berad$!!ext   63 bediff$!!ext   64\
                   bx1$!!ext 65 bx1del$!!ext 66 bx1blost$!!ext 67 bx1fladd$!!ext 68 bx1inj$!!ext 69 bx1rad$!!ext  70 bx1diff$!!ext  71\
                   bx2$!!ext 72 bx2del$!!ext 73 bx2blost$!!ext 74 bx2fladd$!!ext 75 bx2inj$!!ext 76 bx2rad$!!ext  77 bx2diff$!!ext  78\
		   bx3$!!ext 79 bx3del$!!ext 80 bx3blost$!!ext 81 bx3fladd$!!ext 82 bx3inj$!!ext 83 bx3rad$!!ext  84 bx3diff$!!ext  85\
		   ve$!!ext  86 vedel$!!ext  87 veblost$!!ext  88 vefladd$!!ext  89 veinj$!!ext  90 verad$!!ext   91 vediff$!!ext   92}
                   #
		  }
		  # no $fullvec==0 case -- too annoying to redo the numbers
		  define enerreadtest (mrad$!!ext[0])
                 }
                 if($fileversion==5){\
                  set mrad$!!ext=0,0,1
                  set mrad$!!ext[0]=-100
		  if($fullvec){\
		   read {t$!!ext 1 cmode_amp$!!ext 2 smode_amp$!!ext 3\
                   etot$!!ext 4 etotdel$!!ext 5 etotblost$!!ext 6 etotfladd$!!ext 7 etotinj$!!ext 8 etotrad$!!ext 9 etotdiff$!!ext  10\
		   m$!!ext   11 mdel$!!ext   12 mblost$!!ext   13 mfladd$!!ext   14 minj$!!ext   15 mrad$!!ext    16 mdiff$!!ext    17\
                   ie$!!ext  18 iedel$!!ext  19 ieblost$!!ext  20 iefladd$!!ext  21 ieinj$!!ext  22 ierad$!!ext   23 iediff$!!ext   24\
                   pe$!!ext 25 pedel$!!ext 26 peblost$!!ext 27 pefladd$!!ext 28 peinj$!!ext 29 perad$!!ext  30 pediff$!!ext  31\
		   ke$!!ext  32 kedel$!!ext  33 keblost$!!ext  34 kefladd$!!ext  35 keinj$!!ext  36 kerad$!!ext   37 kediff$!!ext   38\
                   mx1$!!ext 39 mx1del$!!ext 40 mx1blost$!!ext 41 mx1fladd$!!ext 42 mx1inj$!!ext 43 mx1rad$!!ext  44 mx1diff$!!ext  45\
                   mx2$!!ext 46 mx2del$!!ext 47 mx2blost$!!ext 48 mx2fladd$!!ext 49 mx2inj$!!ext 50 mx2rad$!!ext  51 mx2diff$!!ext  52\
		   mx3$!!ext 53 mx3del$!!ext 54 mx3blost$!!ext 55 mx3fladd$!!ext 56 mx3inj$!!ext 57 mx3rad$!!ext  58 mx3diff$!!ext  59\
                   be$!!ext  60 bedel$!!ext  61 beblost$!!ext  62 befladd$!!ext  63 beinj$!!ext  64 berad$!!ext   65 bediff$!!ext   66\
                   bx1$!!ext 67 bx1del$!!ext 68 bx1blost$!!ext 69 bx1fladd$!!ext 70 bx1inj$!!ext 71 bx1rad$!!ext  72 bx1diff$!!ext  73\
                   bx2$!!ext 74 bx2del$!!ext 75 bx2blost$!!ext 76 bx2fladd$!!ext 77 bx2inj$!!ext 78 bx2rad$!!ext  79 bx2diff$!!ext  80\
		   bx3$!!ext 81 bx3del$!!ext 82 bx3blost$!!ext 83 bx3fladd$!!ext 84 bx3inj$!!ext 85 bx3rad$!!ext  86 bx3diff$!!ext  87\
		   ve$!!ext  88 vedel$!!ext  89 veblost$!!ext  90 vefladd$!!ext  91 veinj$!!ext  92 verad$!!ext   93 vediff$!!ext   94}
                   #
		  }\
		  else{\
		   read {t$!!ext 1 cmode_amp$!!ext 2 smode_amp$!!ext 3\
                   etot$!!ext 4 etotdel$!!ext 5 etotblost$!!ext 6 etotfladd$!!ext 7 etotinj$!!ext 8 etotrad$!!ext 9 etotdiff$!!ext  10\
		   m$!!ext   11 mdel$!!ext   12 mblost$!!ext   13 mfladd$!!ext   14 minj$!!ext   15 mrad$!!ext    16 mdiff$!!ext    17\
                   ie$!!ext  18 iedel$!!ext  19 ieblost$!!ext  20 iefladd$!!ext  21 ieinj$!!ext  22 ierad$!!ext   23 iediff$!!ext   24\
                   pe$!!ext 25 pedel$!!ext 26 peblost$!!ext 27 pefladd$!!ext 28 peinj$!!ext 29 perad$!!ext  30 pediff$!!ext  31\
		   ke$!!ext  32 kedel$!!ext  33 keblost$!!ext  34 kefladd$!!ext  35 keinj$!!ext  36 kerad$!!ext   37 kediff$!!ext   38\
                   mx1$!!ext 39 mx1del$!!ext 40 mx1blost$!!ext 41 mx1fladd$!!ext 42 mx1inj$!!ext 43 mx1rad$!!ext  44 mx1diff$!!ext  45\
                   mx2$!!ext 46 mx2del$!!ext 47 mx2blost$!!ext 48 mx2fladd$!!ext 49 mx2inj$!!ext 50 mx2rad$!!ext  51 mx2diff$!!ext  52\
		   mx3$!!ext 53 mx3del$!!ext 54 mx3blost$!!ext 55 mx3fladd$!!ext 56 mx3inj$!!ext 57 mx3rad$!!ext  58 mx3diff$!!ext  59\
		   ve$!!ext  60 vedel$!!ext  61 veblost$!!ext  62 vefladd$!!ext  63 veinj$!!ext  64 verad$!!ext   65 vediff$!!ext   66}
                   #
		  }
		  define enerreadtest (mrad$!!ext[0])
                 }		 
                 if($fileversion==4){\
                  set minj$!!ext=0,0,1
                  set minj$!!ext[0]=-100
                  read {t$!!ext 1 cmode_amp$!!ext 2 smode_amp$!!ext 3\
                   etot$!!ext 4 etotdel$!!ext 5 etotblost$!!ext 6 etotfladd$!!ext 7 etotinj$!!ext 8 etotdiff$!!ext 9\
		   m$!!ext   10 mdel$!!ext   11 mblost$!!ext   12 mfladd$!!ext   13 minj$!!ext   14 mdiff$!!ext   15\
                   ie$!!ext  16 iedel$!!ext  17 ieblost$!!ext  18 iefladd$!!ext  19 ieinj$!!ext  20 iediff$!!ext  21\
                   pe$!!ext 22 pedel$!!ext 23 peblost$!!ext 24 pefladd$!!ext 25 peinj$!!ext 26 pediff$!!ext 27\
		   ke$!!ext  28 kedel$!!ext  29 keblost$!!ext  30 kefladd$!!ext  31 keinj$!!ext  32 kediff$!!ext  33\
                   mx1$!!ext 34 mx1del$!!ext 35 mx1blost$!!ext 36 mx1fladd$!!ext 37 mx1inj$!!ext 38 mx1diff$!!ext 39\
                   mx2$!!ext 40 mx2del$!!ext 41 mx2blost$!!ext 42 mx2fladd$!!ext 43 mx2inj$!!ext 44 mx2diff$!!ext 45\
		   mx3$!!ext 46 mx3del$!!ext 47 mx3blost$!!ext 48 mx3fladd$!!ext 49 mx3inj$!!ext 50 mx3diff$!!ext 51\
		   ve$!!ext  52 vedel$!!ext  53 veblost$!!ext  54 vefladd$!!ext  55 veinj$!!ext  56 vediff$!!ext  57}
                  define enerreadtest (minj$!!ext[0])
                 }
                 if($fileversion==3){\
                   set mfladd$!!ext=0,0,1
                   set mfladd$!!ext[0]=-100
                   read {t$!!ext 1 cmode_amp$!!ext 2 smode_amp$!!ext 3\
                   etot$!!ext 4 etotdel$!!ext 5 etotblost$!!ext 6 etotfladd$!!ext 7 etotdiff$!!ext 8\
		   m$!!ext    9 mdel$!!ext   10 mblost$!!ext   11 mfladd$!!ext   12 mdiff$!!ext   13\
                   ie$!!ext  14 iedel$!!ext  15 ieblost$!!ext  16 iefladd$!!ext  17 iediff$!!ext  18\
                   pe$!!ext 19 pedel$!!ext 20 peblost$!!ext 21 pefladd$!!ext 22 pediff$!!ext 23\
		   ke$!!ext  24 kedel$!!ext  25 keblost$!!ext  26 kefladd$!!ext  27 kediff$!!ext  28\
                   mx1$!!ext 29 mx1del$!!ext 30 mx1blost$!!ext 31 mx1fladd$!!ext 32 mx1diff$!!ext 33\
                   mx2$!!ext 34 mx2del$!!ext 35 mx2blost$!!ext 36 mx2fladd$!!ext 37 mx2diff$!!ext 38\
		   mx3$!!ext 39 mx3del$!!ext 40 mx3blost$!!ext 41 mx3fladd$!!ext 42 mx3diff$!!ext 43\
		   ve$!!ext  44 vedel$!!ext  45 veblost$!!ext  46 vefladd $!!ext 47 vediff$!!ext  48}
                   define enerreadtest (mfladd$!!ext[0])
                   #
                 }
                 # ZEUS HISTORY FILE (default)
                 if($fileversion==100){\
                   read {t 1 dt 2 m 3 ie 4 ke1 5 ke2 6 ke3 7 be1 8 be2 9 be3 10 re 11}
 		   set ke = (ke1+ke2+ke3)
		   set be = (be1+be2+be3)
 		   set etot = (ie+ke1+ke2+ke3+be1+be2+be3)
		   set etotdel = (etot-etot[0])
                   define enerreadtest (1)
                   #
                 }
                }
rdreads3   1    #
                if($filetype==$LOSSTYPE){\
                 if($fileversion==5){\
		  if($fullvec){\
                   read {t$!!ext 1 totm$!!ext 2 min1$!!ext 3 mout1$!!ext 4 min2$!!ext 5 mout2$!!ext 6\
			   toth$!!ext 7 hin1$!!ext 8 hout1$!!ext 9 hin2$!!ext 10 hout2$!!ext 11\
			   totpe$!!ext 12 pein1$!!ext 13 peout1$!!ext 14 pein2$!!ext 15 peout2$!!ext 16\
			   totke$!!ext 17 kein1$!!ext 18 keout1$!!ext 19 kein2$!!ext 20 keout2$!!ext 21\
			   totmx1$!!ext 22 mx1in1$!!ext 23 mx1out1$!!ext 24 mx1in2$!!ext 25 mx1out2$!!ext 26\
			   totmx2$!!ext 27 mx2in1$!!ext 28 mx2out1$!!ext 29 mx2in2$!!ext 30 mx2out2$!!ext 31\
			   totmx3$!!ext 32 mx3in1$!!ext 33 mx3out1$!!ext 34 mx3in2$!!ext 35 mx3out2$!!ext 36\
			   totbe$!!ext 37 bein1$!!ext 38 beout1$!!ext 39 bein2$!!ext 40 beout2$!!ext 41\
			   totbx1$!!ext 42 bx1in1$!!ext 43 bx1out1$!!ext 44 bx1in2$!!ext 45 bx1out2$!!ext 46\
			   totbx2$!!ext 47 bx2in1$!!ext 48 bx2out1$!!ext 49 bx2in2$!!ext 50 bx2out2$!!ext 51\
			   totbx3$!!ext 52 bx3in1$!!ext 53 bx3out1$!!ext 54 bx3in2$!!ext 55 bx3out2$!!ext 56\
			   totve$!!ext 57 vein1$!!ext 58 veout1$!!ext 59 vein2$!!ext 60 veout2$!!ext 61}
                   set tote$!!ext=toth$!!ext+totpe$!!ext+totke$!!ext+totbe$!!ext+totve$!!ext
                   set ein1$!!ext=hin1$!!ext+pein1$!!ext+kein1$!!ext+bein1$!!ext+vein1$!!ext
                   set eout1$!!ext=hout1$!!ext+peout1$!!ext+keout1$!!ext+beout1$!!ext+veout1$!!ext
                   set ein2$!!ext=hin2$!!ext+pein2$!!ext+kein2$!!ext+bein2$!!ext+vein2$!!ext
                   set eout2$!!ext=hout2$!!ext+peout2$!!ext+keout2$!!ext+beout2$!!ext+veout2$!!ext
		  }\
		  else{\
                   read {t$!!ext 1 totm$!!ext 2 min1$!!ext 3 mout1$!!ext 4 min2$!!ext 5 mout2$!!ext 6\
			   toth$!!ext 7 hin1$!!ext 8 hout1$!!ext 9 hin2$!!ext 10 hout2$!!ext 11\
			   totpe$!!ext 12 pein1$!!ext 13 peout1$!!ext 14 pein2$!!ext 15 peout2$!!ext 16\
			   totke$!!ext 17 kein1$!!ext 18 keout1$!!ext 19 kein2$!!ext 20 keout2$!!ext 21\
			   totmx1$!!ext 22 mx1in1$!!ext 23 mx1out1$!!ext 24 mx1in2$!!ext 25 mx1out2$!!ext 26\
			   totmx2$!!ext 27 mx2in1$!!ext 28 mx2out1$!!ext 29 mx2in2$!!ext 30 mx2out2$!!ext 31\
			   totmx3$!!ext 32 mx3in1$!!ext 33 mx3out1$!!ext 34 mx3in2$!!ext 35 mx3out2$!!ext 36\
			   totve$!!ext 37 vein1$!!ext 38 veout1$!!ext 39 vein2$!!ext 40 veout2$!!ext 41}
                   set tote$!!ext=toth$!!ext+totpe$!!ext+totke$!!ext+totve$!!ext
                   set ein1$!!ext=hin1$!!ext+pein1$!!ext+kein1$!!ext+vein1$!!ext
                   set eout1$!!ext=hout1$!!ext+peout1$!!ext+keout1$!!ext+veout1$!!ext
                   set ein2$!!ext=hin2$!!ext+pein2$!!ext+kein2$!!ext+vein2$!!ext
                   set eout2$!!ext=hout2$!!ext+peout2$!!ext+keout2$!!ext+veout2$!!ext
		  }
		}
		if($fileversion==6){\
		 if($LOOPTYPE==1){\
                  read {t$!!ext 1 totm$!!ext 2 min1$!!ext 3 mout1$!!ext 4 min2$!!ext 5 mout2$!!ext 6 min3$!!ext 7 mout3$!!ext 8\
		       toth$!!ext 9 hin1$!!ext 10 hout1$!!ext 11 hin2$!!ext 12 hout2$!!ext 13  hin3$!!ext 14 hout3$!!ext 15\
		       totpe$!!ext 16 pein1$!!ext 17 peout1$!!ext 18 pein2$!!ext 19 peout2$!!ext 20 pein3$!!ext 21 peout3$!!ext 22\
		       totke$!!ext 23 kein1$!!ext 24 keout1$!!ext 25 kein2$!!ext 26 keout2$!!ext 27 kein3$!!ext 28 keout3$!!ext 29\
		       totmx1$!!ext 30 mx1in1$!!ext 31 mx1out1$!!ext 32 mx1in2$!!ext 33 mx1out2$!!ext 34 mx1in3$!!ext 35 mx1out3$!!ext 36\
		       totmx2$!!ext 37 mx2in1$!!ext 38 mx2out1$!!ext 39 mx2in2$!!ext 40 mx2out2$!!ext 41 mx2in3$!!ext 42 mx2out3$!!ext 43\
		       totmx3$!!ext 44 mx3in1$!!ext 45 mx3out1$!!ext 46 mx3in2$!!ext 47 mx3out2$!!ext 48 mx3in3$!!ext 49 mx3out3$!!ext 50\
		       totbe$!!ext 51 bein1$!!ext 52 beout1$!!ext 53 bein2$!!ext 54 beout2$!!ext 55 bein3$!!ext 56 beout3$!!ext 57\
		       totbx1$!!ext 58 bx1in1$!!ext 59 bx1out1$!!ext 60 bx1in2$!!ext 61 bx1out2$!!ext 62 bx1in3$!!ext 63 bx1out3$!!ext 64\
		       totbx2$!!ext 65 bx2in1$!!ext 66 bx2out1$!!ext 67 bx2in2$!!ext 68 bx2out2$!!ext 69 bx2in3$!!ext 70 bx2out3$!!ext 71\
		       totbx3$!!ext 72 bx3in1$!!ext 73 bx3out1$!!ext 74 bx3in2$!!ext 75 bx3out2$!!ext 76 bx3in3$!!ext 77 bx3out3$!!ext 78\
		       totve$!!ext 79 vein1$!!ext 80 veout1$!!ext 81 vein2$!!ext 82 veout2$!!ext 83 vein3$!!ext 84 veout3$!!ext 85}
                        set tote$!!ext=toth$!!ext+totpe$!!ext+totke$!!ext+totbe$!!ext+totve$!!ext
                        set ein1$!!ext=hin1$!!ext+pein1$!!ext+kein1$!!ext+bein1$!!ext+vein1$!!ext
                        set eout1$!!ext=hout1$!!ext+peout1$!!ext+keout1$!!ext+beout1$!!ext+veout1$!!ext
                        set ein2$!!ext=hin2$!!ext+pein2$!!ext+kein2$!!ext+bein2$!!ext+vein2$!!ext
                        set eout2$!!ext=hout2$!!ext+peout2$!!ext+keout2$!!ext+beout2$!!ext+veout2$!!ext
		        set ein3$!!ext=hin3$!!ext+pein3$!!ext+kein3$!!ext+bein3$!!ext+vein3$!!ext
                        set eout3$!!ext=hout3$!!ext+peout3$!!ext+keout3$!!ext+beout3$!!ext+veout3$!!ext
		  }
		  if($LOOPTYPE>1){\
                   read {t$!!ext 1 min$!!ext 2 mout$!!ext 3\
		                   hin$!!ext 4 hout$!!ext 5\
		                   pein$!!ext 6 peout$!!ext 7\
		                   kein$!!ext 8 keout$!!ext 9\
		                   mx1in$!!ext 10 mx1out$!!ext 11\
		                   mx2in$!!ext 12 mx2out$!!ext 13\
		                   mx3in$!!ext 14 mx3out$!!ext 15\
		                   bein$!!ext 16 beout$!!ext 17\
		                   bx1in$!!ext 18 bx1out$!!ext 19\
		                   bx2in$!!ext 20 bx2out$!!ext 21\
		                   bx3in$!!ext 22 bx3out$!!ext 23\
		                   vein$!!ext 24 veout$!!ext 25}
		   set mflux$!!ext = min$!!ext + mout$!!ext
		   set hflux$!!ext = hin$!!ext + hout$!!ext
		   set peflux$!!ext = pein$!!ext + peout$!!ext
		   set keflux$!!ext = kein$!!ext + keout$!!ext
		   set mx1flux$!!ext = mx1in$!!ext + mx1out$!!ext
		   set mx2flux$!!ext = mx2in$!!ext + mx2out$!!ext
		   set mx3flux$!!ext = mx3in$!!ext + mx3out$!!ext
		   set beflux$!!ext = bein$!!ext + beout$!!ext
		   set bx1flux$!!ext = bx1in$!!ext + bx1out$!!ext
		   set bx2flux$!!ext = bx2in$!!ext + bx2out$!!ext
		   set bx3flux$!!ext = bx3in$!!ext + bx3out$!!ext
		   set veflux$!!ext = vein$!!ext + veout$!!ext
	 	
	 	   set ein$!!ext=hin$!!ext+pein$!!ext+kein$!!ext+bein$!!ext+vein$!!ext
		   set eout$!!ext=hout$!!ext+peout$!!ext+keout$!!ext+beout$!!ext+veout$!!ext
	 	   set eflux$!!ext=ein$!!ext+eout$!!ext
		}
		}
		}
rdreads32	1 # second part	
                if($filetype==$SPTYPE){\
                 if($fileversion==1){\
                  read {t$!!ext 1 x1l$!!ext 2 x1h$!!ext 3  x2l$!!ext 4 x2h$!!ext 5  totl$!!ext 6 toth$!!ext 7}
                 }
                }
                if($filetype==$TSTYPE){\
                 if($fileversion==1){\
                  read {t 1 \
			p0c2$!!ext  2 p0c3$!!ext  3 p0c4$!!ext  4 p0c5$!!ext  5 p0c6$!!ext  6 p0c7$!!ext  7 p0c8$!!ext  8 p0c9$!!ext  9 p0c10$!!ext 10 \
		        p1c2$!!ext 11 p1c3$!!ext 12 p1c4$!!ext 13 p1c5$!!ext 14 p1c6$!!ext 15 p1c7$!!ext 16 p1c8$!!ext 17 p1c9$!!ext 18 p1c10$!!ext 19 \
		        p2c2$!!ext 20 p2c3$!!ext 21 p2c4$!!ext 22 p2c5$!!ext 23 p2c6$!!ext 24 p2c7$!!ext 25 p2c8$!!ext 26 p2c9$!!ext 27 p2c10$!!ext 28 \
		        p3c2$!!ext 29 p3c3$!!ext 30 p3c4$!!ext 31 p3c5$!!ext 32 p3c6$!!ext 33 p3c7$!!ext 34 p3c8$!!ext 35 p3c9$!!ext 36 p3c10$!!ext 37 \
		        p4c2$!!ext 38 p4c3$!!ext 39 p4c4$!!ext 40 p4c5$!!ext 41 p4c6$!!ext 42 p4c7$!!ext 43 p4c8$!!ext 44 p4c9$!!ext 45 p4c10$!!ext 46}
                 }
                }
                if($filetype==$LOGDTTYPE){\
                 if($fileversion==1){\
                  read {t$!!ext 1 dt$!!ext 2 r$!!ext 3 w$!!ext 4 l$!!ext 5 k$!!ext 6 j$!!ext 7 i$!!ext 8 x1$!!ext 9 x2$!!ext 10 \
                   cs_dt$!!ext 11 cs_v$!!ext 12 x1v_dt$!!ext 13 x1v_v$!!ext 14 x2v_dt$!!ext 15 x2v_v$!!ext 16 bv_dt$!!ext 17 bv_v$!!ext 18 lv_dt$!!ext 19\
                   lv_dv$!!ext 20 vx1_dt$!!ext 21 vx1_dv$!!ext 22 vx2_dt$!!ext 23 vx2_dv$!!ext 24 rvx1_dt$!!ext 25 rvx1_nu$!!ext 26 rvx2_dt$!!ext 27\
                   rvx2_nu$!!ext 28 res_dt$!!ext 29 res_v$!!ext 30}
                 }
                }
                if($filetype==$STEPTYPE){\
                 if($fileversion==1){\
                  read {n$!!ext 1 nn$!!ext 2 nsup$!!ext 3 nsub$!!ext 4 t$!!ext 5 dt$!!ext 6 upto$!!ext 7 i$!!ext 8 N$!!ext 9}
                 }
                }
                if($filetype==$PERFTYPE){\
                 if($fileversion==3){\
                  read {t$!!ext 1 ete$!!ext 2 n$!!ext 3 wt$!!ext 4 zc$!!ext 5 tuphr$!!ext 6 lete$!!ext 7 ln$!!ext 8 lwt$!!ext 9 lzc$!!ext 10 ltuphr$!!ext 11}
                  #t, ete, n, wt, zc, tu/hr,  lete, ln, lwt, lzc, ltu/hr 
                 }
                 if($fileversion==2){\
                  read {proc$!!ext 1 t$!!ext 2 ete$!!ext 3 n$!!ext 4 wt$!!ext 5 zc$!!ext 6 tuphr$!!ext 7 lete$!!ext 8 ln$!!ext 9 lwt$!!ext 10 lzc$!!ext 11 ltuphr$!!ext 12}
                 }
                 if($fileversion==1){\
                  read {proc$!!ext 1 ete$!!ext 2 n$!!ext 3 wt$!!ext 4 zc$!!ext 5 lete$!!ext 6 ln$!!ext 7 lwt$!!ext 8 lzc$!!ext 9}
                 }
                }
                #
rdreads4 1      #
		if($filetype==$MODETYPE){\
                 # only version so far!
		 # 10 modes, 0-9
		 if($fileversion==1){\
                        read {t$!!ext 1 m0$!!ext 2 m1$!!ext 3 m2$!!ext 4 m3$!!ext 5 m4$!!ext 6 m5$!!ext 7 m6$!!ext 8 m7$!!ext 9 m8$!!ext 10 m9$!!ext 11}
                 }
                 if($fileversion==2){\
		        read {t$!!ext 1 \
		        rm0$!!ext  2 rm1$!!ext 3 rm2$!!ext 4 rm3$!!ext 5 rm4$!!ext 6 rm5$!!ext 7 rm6$!!ext 8 rm7$!!ext 9 rm8$!!ext 10 rm9$!!ext 11 \
		        em0$!!ext  12 em1$!!ext 13 em2$!!ext 14 em3$!!ext 15 em4$!!ext 16 em5$!!ext 17 em6$!!ext 18 em7$!!ext 19 em8$!!ext 20 em9$!!ext 21 \
		        pem0$!!ext 22 pem1$!!ext 23 pem2$!!ext 24 pem3$!!ext 25 pem4$!!ext 26 pem5$!!ext 27 pem6$!!ext 28 pem7$!!ext 29 pem8$!!ext 30 pem9$!!ext 31 \
		        vm0$!!extx 32 vm1$!!extx 33 vm2$!!extx 34 vm3$!!extx 35 vm4$!!extx 36 vm5$!!extx 37 vm6$!!extx 38 vm7$!!extx 39 vm8$!!extx 40 vm9$!!extx 41 \
		        vm0$!!exty 42 vm1$!!exty 43 vm2$!!exty 44 vm3$!!exty 45 vm4$!!exty 46 vm5$!!exty 47 vm6$!!exty 48 vm7$!!exty 49 vm8$!!exty 50 vm9$!!exty 51 \
		        vm0$!!extz 52 vm1$!!extz 53 vm2$!!extz 54 vm3$!!extz 55 vm4$!!extz 56 vm5$!!extz 57 vm6$!!extz 58 vm7$!!extz 59 vm8$!!extz 60 vm9$!!extz 61 \
		        bm0$!!extx 62 bm1$!!extx 63 bm2$!!extx 64 bm3$!!extx 65 bm4$!!extx 66 bm5$!!extx 67 bm6$!!extx 68 bm7$!!extx 69 bm8$!!extx 70 bm9$!!extx 71 \
		        bm0$!!exty 72 bm1$!!exty 73 bm2$!!exty 74 bm3$!!exty 75 bm4$!!exty 76 bm5$!!exty 77 bm6$!!exty 78 bm7$!!exty 79 bm8$!!exty 80 bm9$!!exty 81 \
		        bm0$!!extz 82 bm1$!!extz 83 bm2$!!extz 84 bm3$!!extz 85 bm4$!!extz 86 bm5$!!extz 87 bm6$!!extz 88 bm7$!!extz 89 bm8$!!extz 90 bm9$!!extz 91}
		 }
		}
		#
rdcalcs1 1      #
                # any cross-grid stuff below assumes DUMPSM==1 in code
                #
                # if $gam changes, $gam stuff is wrong!
                if(($filetype==$DTYPE)||($filetype==$PDTYPE)||($filetype==$ADTYPE)||($filetype==$FLTYPE)||($filetype==$AVG2DTYPE)||($filetype==$AVG1DTYPE)){\
                 set p$!!ext = ($gam-1.)*en$!!ext
                 if(wgam){\
                   set csq$!!ext = $gam*($gam-1.)*en$!!ext/r$!!ext
	           set cs$!!ext = SQRT(csq$!!ext)
                   set cstimex1$!!ext = cs$!!ext/dx1
                   set cstimex2$!!ext = cs$!!ext/dx2
                 }
 		 if(_mag){\
                  set b2$!!ext = bx**2+by**2+bz**2
                  set absb$!!ext = sqrt(b2$!!ext)
                  set va$!!ext = absb/sqrt(r$!!ext)
		  set va$!!extx = ABS(bx)/sqrt(r$!!ext)
		  set vatimex1$!!ext = va$!!ext/dx1
		  set vatimex2$!!ext = va$!!ext/dx2
		 }\
		 else{\
			set b2$!!ext = 0
			set absb$!!ext = 0
			set va$!!ext = 0
		        set va$!!extx = 0
			set vatimex1$!!ext = 0
			set vatimex2$!!ext = 0
		 }
                 set tottimex1$!!ext = (va$!!ext+cs$!!ext)/dx1
		 set tottimex2$!!ext = (va$!!ext+cs$!!ext)/(x12*dx2)
                 set ltottimex1$!!ext = (absb/SQRT(r+b2$!!ext)+cs$!!ext)/dx1
		 set ltottimex2$!!ext = (absb/SQRT(r+b2$!!ext)+cs$!!ext)/(x12*dx2)
                 set vtotsq$!!ext = v$!!extx*v$!!extx+v$!!exty*v$!!exty+v$!!extz*v$!!extz
                 set vtot$!!ext = SQRT(vtotsq$!!ext)
                 set enthalpy$!!ext = $gam*en$!!ext/r$!!ext
		 if(ABS($gam-1.)<.000001){\
					  set entropy$!!ext = r$!!ext/r$!!ext
		                         }\
   		                         else{\
		                          set entropy$!!ext = ($gam-1.)*en$!!ext/r$!!ext**($gam)
		                         }
                 set Mach$!!extx = (v$!!extx/(cs$!!ext+va$!!ext))
		 set Machcs$!!extx = (v$!!extx/(cs$!!ext))
		 set Machva$!!extx = (v$!!extx/(va$!!ext))
                 set Mach$!!exty = (v$!!exty/(cs$!!ext+va$!!ext))
                 set Mach$!!extz = (v$!!extz/(cs$!!ext+va$!!ext))
                 set Machv$!!ext = (vtot$!!ext/cs$!!ext)
                 set dl$!!ext = r$!!ext*(v$!!extz*x12*g42-SQRT(x12*g42))
		 if(_mag==1){\
		        set Be$!!ext = vtotsq$!!ext*0.5+enthalpy$!!ext+pot$!!ext+0.5*b2$!!ext
		     }\
		            else{\
                        set Be$!!ext = vtotsq$!!ext*0.5+enthalpy$!!ext+pot$!!ext
		     }
                 set se$!!ext = en$!!ext/r$!!ext
		 set ek$!!ext = 0.5*r$!!ext*vtotsq$!!ext
		 set p$!!extx = v$!!extx*r$!!ext
		 set p$!!exty = v$!!exty*r$!!ext
		 set lr$!!ext = LG(r$!!ext)
                 set len$!!ext = LG(en$!!ext)
                 set rv$!!extx = r$!!ext*v$!!extx
                 set rvxsq$!!ext = r$!!ext*v$!!extx*v$!!extx
		 set rv$!!exty = r$!!ext*v$!!exty
		 set rvysq$!!ext = r$!!ext*v$!!exty*v$!!exty
		 set rv$!!extz = r$!!ext*v$!!extz
		 set rvzsq$!!ext = r$!!ext*v$!!extz*v$!!extz
		 if($COORD==3){\
		        set angmom3$!!ext = x12*g42*r$!!ext*v$!!extz
		     }
		 if($COORD==1){\
		            set angmom3=sqrt(x1**2+x2**2+x3**2)*sqrt(vx**2+vy**2)*r*dx1*dx2*dx3
		         }
                 # spherical rotation
		 set omega3$!!ext = v$!!extz/(x12*g42)
                 set omegak$!!ext = sqrt(1.0/(x12**3 * (1.0-2/x12)**2 ) )
		 if(_mag){\
                  set dx1mri=dx1*(ABS(omega3))/(2*PI*ABS(va))
                  set dx2mri=x1*(ABS(omega3))*dx2/(2*PI*ABS(va))
		 }
                 if($npdone){\
                  # visc times for various perscriptions
                  #need to divide by alpha
                  # for IGU
                  #set visctime$!!ext=x12*x12*omegak$!!ext/(cs$!!ext*cs$!!ext)/$alphareal0
		  set lvisctimex$!!ext=dx12*dx12/(nuvisc$!!ext)
		  set lvisctimey$!!ext=g32*g32*dx22*dx22/(nuvisc$!!ext)
		  set visctime$!!ext=x12*x12/(nuvisc$!!ext)
                 }
                 set mass=r$!!ext*dvl1*dvl2

                 # Mass Flux density
                 set Fmd$!!extx=r$!!ext*v$!!extx
                 set Fmd$!!exty=r$!!ext*v$!!exty
                 set Fmd$!!extz=r$!!ext*v$!!extz

                 # Mass Flux(full reduced derivative argument, all left is ds)
                 set Fm$!!extx=g22*g32*g42*r$!!ext*v$!!extx
                 set Fm$!!exty=g32*g42*r$!!ext*v$!!exty
                 set Fm$!!extz=g32*r$!!ext*v$!!extz

                 # Ang mom Reynolds flux density(argument of divergence)
                 set FPvzd$!!extx=g32*g42*(r$!!ext*v$!!extx*v$!!extz)
                 set FPvzd$!!exty=g32*g42*(r$!!ext*v$!!exty*v$!!extz)
                 set FPvzd$!!extz=g32*g42*(r$!!ext*v$!!extz*v$!!extz)

                 # Ang mom Reynolds flux(full reduced derivative argument)
                 set FPvz$!!extx=g22*g32*g32*g42*g42*(r$!!ext*v$!!extx*v$!!extz)
                 set FPvz$!!exty=g22*g32*g42*g42*(r$!!ext*v$!!exty*v$!!extz)
                 set FPvz$!!extz=g22*g32*g42*(r$!!ext*v$!!extz*v$!!extz)

                 # Energy Flux (density(argument) and full derivative argument)
                 set temp$!!ext=0.5*vtotsq$!!ext+enthalpy$!!ext+pot$!!ext

                 set FPEd$!!extx =  temp$!!ext*Fmd$!!extx
                 set FPEd$!!exty =  temp$!!ext*Fmd$!!exty
                 set FPEd$!!extz =  temp$!!ext*Fmd$!!extz
                }
rdcalcs2   1    #
                # viscosity and total only parts
                if(($filetype==$DTYPE)||($filetype==$PDTYPE)||($filetype==$ADTYPE)||($filetype==$FLTYPE)||($filetype==$AVG2DTYPE)||($filetype==$AVG1DTYPE)){\
		 if($npdone){\
                  set alphavisc=sig13$!!ext/p
                  # Ang mom viscous flux density(argument of divergence)
                  set FVvzd$!!extx=g32*g42*sig13$!!ext
                  set FVvzd$!!exty=g32*g42*sig23$!!ext
                  set FVvzd$!!extz=g32*g42*sig33$!!ext

                  # Ang mom viscous flux(full reduced derivative argument)
                  set FVvz$!!extx=g22*g32*g22*g42*g42*sig13$!!ext
                  set FVvz$!!exty=g22*g32*g42*g42*sig23$!!ext
                  set FVvz$!!extz=g22*g32*g42*sig33$!!ext
		 }\
                 else{\
                  set FVvzdx=0
                  set FVvzdy=0
                  set FVvzdz=0
                  set FVvzx=0
                  set FVvzy=0
                  set FVvzz=0
		 }
                 # Total ang mom flux density(argument of divergence)
                 set Fvzd$!!extx = FPvzd$!!extx+FVvzd$!!extx
                 set Fvzd$!!exty = FPvzd$!!exty+FVvzd$!!exty
                 set Fvzd$!!extz = FPvzd$!!extz+FVvzd$!!extz

                 # Total ang mom flux(full reduced derivative argument)
                 set Fvz$!!extx = FPvz$!!extx+FVvz$!!extx
                 set Fvz$!!exty = FPvz$!!exty+FVvz$!!exty
                 set Fvz$!!extz = FPvz$!!extz+FVvz$!!extz
                 #
                 #
		 if($npdone){\
                  # argument to divergence only
                  set FVEd$!!extx = sig13$!!ext*v$!!extz+sig12$!!ext*v$!!exty+sig11$!!ext*v$!!extx
                  set FVEd$!!exty = sig23$!!ext*v$!!extz+sig22$!!ext*v$!!exty+sig21$!!ext*v$!!extx
                  set FVEd$!!extz = sig33$!!ext*v$!!extz+sig32$!!ext*v$!!exty+sig31$!!ext*v$!!extx
		 }\
		 else{\
                  set FVEdx=0
                  set FVEdy=0
                  set FVEdz=0
		 }
                 set FEd$!!extx = FVEd$!!extx+FPEd$!!extx
                 set FEd$!!exty = FVEd$!!exty+FPEd$!!exty
                 set FEd$!!extz = FVEd$!!extz+FPEd$!!extz

		 if($npdone){\
                  # full reduced arguments
                  set FVE$!!extx = g22*g32*g42*(sig13$!!ext*v$!!extz+sig12$!!ext*v$!!exty+sig11$!!ext*v$!!extx)
                  set FVE$!!exty = g32*g42*(sig23$!!ext*v$!!extz+sig22$!!ext*v$!!exty+sig21$!!ext*v$!!extx)
		  set FVE$!!extz = g32*(sig33$!!ext*v$!!extz+sig32$!!ext*v$!!exty+sig31$!!ext*v$!!extx)
		 }\
		 else{\
                  set FVEx=0
                  set FVEy=0
                  set FVEz=0
		 }
                 set FPE$!!extx =  temp$!!ext*Fm$!!extx
                 set FPE$!!exty =  temp$!!ext*Fm$!!exty
                 set FPE$!!extz =  temp$!!ext*Fm$!!extz
 
                 set FE$!!extx = FVE$!!extx+FPE$!!extx
                 set FE$!!exty = FVE$!!exty+FPE$!!exty
                 set FE$!!extz = FVE$!!extz+FPE$!!extz
                
		 if($npdone){\
                  # NP calcs (assume npdump already read in once dump hit)
                  if(($filetype==$DTYPE)||($filetype==$AVG2DTYPE)||($filetype==$AVG1DTYPE)){\
		   if($fileversion==1){\
                    set tempvisc=nuvisc if(nuvisc>0)
                    if(dimen(tempvisc)>0){\
                     set Phi$!!ext = (sig11$!!ext*sig11$!!ext+sig22$!!ext*sig22$!!ext+sig33$!!ext*sig33$!!ext+2.0*sig13$!!ext*sig13$!!ext+2.0*sig23$!!ext*sig23$!!ext+2.0*sig21$!!ext*sig21$!!ext)/(2.0*r$!!ext*nuvisc$!!ext)
                    }
                   }
		 
 		   if($fileversion==0){\
		    # probably MG prescription if this is the case, but may be turned off at a certain time, but sigmas will take care of that.
		    set nuvisc$!!ext=_alphareal0*cs$!!ext*cs$!!ext/omegak$!!ext*g42**(1.5)
		    set Phi$!!ext = (sig11$!!ext*sig11$!!ext+sig22$!!ext*sig22$!!ext+sig33$!!ext*sig33$!!ext+2.0*sig13$!!ext*sig13$!!ext+2.0*sig23$!!ext*sig23$!!ext+2.0*sig21$!!ext*sig21$!!ext)/(2.0*r$!!ext*nuvisc$!!ext)
                   }
                  }
		 }
		}
                # AVG2D calcs
                if($filetype==$AVG2DTYPE){\
                     #                
                }
                # AVG1D calcs
                if($filetype==$AVG1DTYPE){\
                 set lx1$!!ext = LG(x1$!!ext)
                 #set lx2$!!ext = LG(x2$!!ext)
                 set lr1d1$!!ext = LG(r1d1$!!ext)
                 set len1d1$!!ext = LG(en1d1$!!ext)
                 set lbe1d1$!!ext = LG(ABS(be1d1$!!ext))
                 set lcsq1d1$!!ext = LG(csq1d1$!!ext)
                 set ls1d1$!!ext = LG(ABS(s1d1$!!ext))
                 set lvx1d1$!!ext = LG(v1d1$!!extx)
                 set lvy1d1$!!ext = LG(ABS(v1d1$!!exty))
                 set lvz1d1$!!ext = LG(v1d1$!!extz)
                 set lr1d2$!!ext = LG(r1d2$!!ext)
                 set len1d2$!!ext = LG(en1d2$!!ext)
                 set lbe1d2$!!ext = LG(ABS(be1d2$!!ext))
                 set lcsq1d2$!!ext = LG(csq1d2$!!ext)
                 set ls1d2$!!ext = LG(ABS(s1d2$!!ext))
                 set lvx1d2$!!ext = LG(v1d2$!!extx)
                 set lvy1d2$!!ext = LG(ABS(v1d2$!!exty))
                 set lvz1d2$!!ext = LG(v1d2$!!extz)
                 set Mach1$!!extx  = v1d1$!!extx/SQRT(csq1d1$!!ext)
                 set Mach2$!!extx  = v1d2$!!extx/SQRT(csq1d2$!!ext)
                }
                # CALC calcs
                if($filetype==$CALCTYPE){\
                 set L$!!extx  = LR$!!extx+LV$!!extx
                 set L$!!exty  = LR$!!exty+LV$!!exty
                 set L$!!extz  = LR$!!extz+LV$!!extz
                 set E$!!extx  = ER$!!extx+EV$!!extx
                 set E$!!exty  = ER$!!exty+EV$!!exty
                 set E$!!extz  = ER$!!extz+EV$!!extz
                }
		if($filetype==$FIELDLINETYPE){\
		       #
		       }
                #
                if($filetype==$DTYPE){\
                 #rot180del r newr
                 #rot180delv vx newvx
                 #rot180delv vy newvy
		}
                #
plc    17	# plc <file> <function> <type of plot=100,000,overlay=010,000,limits=000,001> <0 0 0 0>
		# this is a generic setup below
                prepaxes x1 x2 $2
                if($?3 == 1) { define tobebits ($3) } else { define tobebits (0x0) }
                #defaults
                #expand 1.3
                #location 3500 17250 3500 31000
                location 3500 31000 3500 31000
                #window 2 1 1 1
                myrd $1
                if('$tobebits'=='000'){\
                 set thebits=0x0
		}\
                else{\
                 set thebits=0x$tobebits
		}
		if(thebits & 0x001){\
                  shrink3 $2 reallyx reallyy newfun $4 $5 $6 $7
                }\
                else{\
		 if($PLANE==3){\
                   define xl ($Sx)
	   	   define xh ($Sx+$Lx)
		   define yl ($Sy)
		   define yh ($Sy+$Ly)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($nx)
                   define ryl (0)
                   define ryh ($ny)
                   define rnx ($nx)
                   define rny ($ny)
                   #image ($nx,$ny) $xl $xh $yl $yh
                   #image ($nx,$ny) $rxl $rxh $ryl $ryh
                   #image ($nx,$ny)
                   #set reallyx=x1
                   #set reallyy=x2
                   #set reallyx=x12 # don't need for plc
                   #set reallyy=x22 # don't need for plc
                   set newfun=$2  # if(k==0) for example
		   define realdx ($dx)
		   define realdy ($dy)
		   #
		 }
		 if($PLANE==2){\
                   define xl ($Sx)
	   	   define xh ($Sx+$Lx)
		   define yl ($Sz)
		   define yh ($Sz+$Lz)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($nx)
                   define ryl (0)
                   define ryh ($nz)
                   define rnx ($nx)
                   define rny ($nz)
                   set newfun=$2 # if(j==0)
		   define realdx ($dx)
		   define realdy ($dz)
	   	   #
		 }
		 if($PLANE==1){\
                   define xl ($Sy)
	   	   define xh ($Sy+$Ly)
		   define yl ($Sz)
		   define yh ($Sz+$Lz)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($ny)
                   define ryl (0)
                   define ryh ($nz)
                   define rnx ($ny)
                   define rny ($nz)
                   set newfun=$2 # if(i==0)   
		   define realdx ($dy)
		   define realdy ($dz)
	   	   #
		 }		 
                }
		set ii=1,$rnx*$rny
		if($SKIPFACTOR>1){\
		 if( $SKIPFACTOR>$rnx/2-1 ||  $SKIPFACTOR>$rny/2-1){\
		  if($rny<$rnx){\
		   set temptemp=int($rny/2-1)
		   define SKIPFACTOR (temptemp)
		  }\
		  else{\
		   set temptemp=int($rnx/2-1)
		   define SKIPFACTOR (temptemp)
		  }
		 }
		 set ii=0,$rnx*$rny-1
		 set iix = ii%$rnx+1
		 set iiy = int(ii/$rnx)+1
		 set use = (int(iiy/$SKIPFACTOR) - iiy/$SKIPFACTOR == 0 && int(iix/$SKIPFACTOR) - iix/$SKIPFACTOR == 0  ) ? 1 : 0
		 set temptempnx=int($rnx/$SKIPFACTOR)
		 set temptempny=int($rny/$SKIPFACTOR)
		 define rnx (temptempnx)
		 define rny (temptempny)
		 set ii=0,$rnx*$rny-1
		 set ix = ii%$rnx
		 set iy = int(ii/$rnx)
		}\
		else{\
		 set x=(ii - $rnx*int((ii-0.5)/$rnx) - 0.5)*$realdx+$txl
		 set y=((int((ii-0.5)/$rnx) + 0.5)*$realdy)+$tyl
		 set ix = int((x -$txl)/$realdx)
		 set iy = int((y -$tyl)/$realdy)
		 set use=ii/ii*1		 
		}
		#
		set newfuntemp=newfun if(use)
		set newfun=newfuntemp
		#set realx1=reallyx if(use)  # don't need for plc
		#set realy1=reallyy if(use) # don't need for plc
		#
		if(!(thebits & 0x010)){\
                 limits $txl $txh $tyl $tyh
		}
		image ($rnx,$rny) $txl $txh $tyl $tyh
		#
                set image[ix,iy] = newfun
                #limits $rxl $rxh $ryl $ryh
                #device ppm file1.ppm
                # default(0) to not overlay
                if(thebits & 0x010){\
                   define temptemptemp (1)
                }\
                else{
		 if($PLOTERASE){\
                  erase
		 }
		 ctype default
                 labeltime
                }
		# the above portion is a generic setup
		if($CONSTLEVELS==0){\
		 minmax min max
		}\
		else{\
		 if(constlevelshit==0){\
		  set constlevelshit=1
		  minmax min max
		 }
		}
		if($loginterprho==1){\
		       define min -3.7
		       define max -2
		    }
                echo "min:"$min "max:"$max
                # define cres (15) # see plc
		if(($SOLIDCONTOURS==0)&&($min*$max < 0.)) {\
                        echo "pt:1"
			define delta (($max-$min)/$cres)
                        echo "delta:"$delta
                        if($min>-$delta){\
                          define min -$delta
                        }
			set lev=$min,-$delta,$delta
			levels lev
			ltype 4
			contour
			#
                        if($max<$delta){\
                          define max $delta
                        }
			set lev=$delta,$max,$delta
			levels lev
			ltype 0
			contour
		}
		if(($min<=0)&&($max<=0)) {\
                        echo "pt:2"
			set lev=$min,$max,($max-$min)/$cres
			levels lev
			#ltype 2
                        ltype 0
			contour
		}
		if(($SOLIDCONTOURS==1)||($min>=0)&&($max>=0)) {\
                        echo "pt:3"
			set lev=$min,$max,($max-$min)/$cres
			levels lev
			ltype 0
			contour
		}
                if(thebits & 0x010){\
                  define temptemptemp (0)
                }\
                else{\
                 if(thebits & 0x100){\
                  ticksize -1 0 0 0
                  box
                  relocate (15000 31500)
                  label RADIAL SCALE NOT EXACTLY CORRECT
		 }\
		 else{\
                  mybox2d
		 }
                 labelaxes 1
		}
                #
                #device X11
pls    17	# pls <file> <function> <type of plot=100,000,overlay=010,000,limits=000,001> <0 0 0 0>
                prepaxes x1 x2 $2
                if($?3 == 1) { define tobebits ($3) } else { define tobebits (0x0) }
                #defaults
                #expand 1.3
                #location 3500 17250 3500 31000
                location 3500 31000 3500 31000
                #window 2 1 1 1
                myrd $1
                if('$tobebits'=='000'){\
                 set thebits=0x0
		}\
                else{\
                 set thebits=0x$tobebits
		}
                if(thebits & 0x001){\
                  shrink3 $2 reallyx reallyy newfun $4 $5 $6 $7
                }\
                else{\
		         		 if($PLANE==3){\
                   define xl ($Sx)
	   	   define xh ($Sx+$Lx)
		   define yl ($Sy)
		   define yh ($Sy+$Ly)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($nx)
                   define ryl (0)
                   define ryh ($ny)
                   define rnx ($nx)
                   define rny ($ny)
                   #image ($nx,$ny) $xl $xh $yl $yh
                   #image ($nx,$ny) $rxl $rxh $ryl $ryh
                   #image ($nx,$ny)
                   #set reallyx=x1
                   #set reallyy=x2
                   #set reallyx=x12 # don't need for plc
                   #set reallyy=x22 # don't need for plc
                   set newfun=$2  # if(k==0) for example
		   define realdx ($dx)
		   define realdy ($dy)
		   set reallyx=x12
                   set reallyy=x22
		   #
		 }
		 if($PLANE==2){\
                   define xl ($Sx)
	   	   define xh ($Sx+$Lx)
		   define yl ($Sz)
		   define yh ($Sz+$Lz)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($nx)
                   define ryl (0)
                   define ryh ($nz)
                   define rnx ($nx)
                   define rny ($nz)
                   set newfun=$2 # if(j==0)
		   define realdx ($dx)
		   define realdy ($dz)
	   	   #
		   set reallyx=x12
                   set reallyy=x32
		 }
		 if($PLANE==1){\
                   define xl ($Sy)
	   	   define xh ($Sy+$Ly)
		   define yl ($Sz)
		   define yh ($Sz+$Lz)
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($ny)
                   define ryl (0)
                   define ryh ($nz)
                   define rnx ($ny)
                   define rny ($nz)
                   set newfun=$2 # if(i==0)   
		   define realdx ($dy)
		   define realdy ($dz)
		   set reallyx=x22
                   set reallyy=x32
	   	   #
		 }		 
                }
		set ii=1,$rnx*$rny
		if($SKIPFACTOR>1){\
		 if( $SKIPFACTOR>$rnx/2-1 ||  $SKIPFACTOR>$rny/2-1){\
		  if($rny<$rnx){\
		   set temptemp=int($rny/2-1)
		   define SKIPFACTOR (temptemp)
		  }\
		  else{\
		   set temptemp=int($rnx/2-1)
		   define SKIPFACTOR (temptemp)
		  }
		 }
		 set ii=0,$rnx*$rny-1
		 set iix = ii%$rnx+1
		 set iiy = int(ii/$rnx)+1
		 set use = (int(iiy/$SKIPFACTOR) - iiy/$SKIPFACTOR == 0 && int(iix/$SKIPFACTOR) - iix/$SKIPFACTOR == 0  ) ? 1 : 0
		 set temptempnx=int($rnx/$SKIPFACTOR)
		 set temptempny=int($rny/$SKIPFACTOR)
		 define rnx (temptempnx)
		 define rny (temptempny)
		 set ii=0,$rnx*$rny-1
		 set ix = ii%$rnx
		 set iy = int(ii/$rnx)
		}\
		else{\
		 set x=(ii - $rnx*int((ii-0.5)/$rnx) - 0.5)*$realdx+$txl
		 set y=((int((ii-0.5)/$rnx) + 0.5)*$realdy)+$tyl
		 set ix = int((x -$txl)/$realdx)
		 set iy = int((y -$tyl)/$realdy)
		 set use=ii/ii*1		 
		}
		#
		set newfuntemp=newfun if(use)
		set newfun=newfuntemp
		set realx1=reallyx if(use)
		set realy1=reallyy if(use)
		#
		if(!(thebits & 0x010)){\
                 limits $txl $txh $tyl $tyh
		}
		#image ($nx,$ny) $xl $xh $yl $yh
		#image ($rnx,$rny)
		image ($rnx,$rny)
		#
                set image[ix,iy] = newfun
		#set image[ix,iy] = $2[ii-1]
                set realx=0,$rnx-1
                set realy=0,$rny-1
                do k=0,$rnx-1,1{
                  set realx[$k] = realx1[$k]
                }
                do k=0,$rny-1,1{
                  set realy[$k] = realy1[$k*$rnx]
                }
                #
		if(!(thebits & 0x010)){\
                 limits 0 $rnx 0 $rny
		}
                #limits $rxl $rxh $ryl $ryh
                minmax min max echo $min $max
		if(!(thebits & 0x010)){\
                 limits 0 $rnx 0 $rny
		}
                #limits $rxl $rxh $ryl $ryh
                #device ppm file1.ppm
                # default(0) to not overlay
                if(thebits & 0x010){\
                   define temptemptemp (1)
                }\
                else{
                 erase
		 ctype default
                 labeltime
                }
                # else overlay
	        load surfaces
                Viewpoint 50 50 0
		#Viewpoint 80 80 0
                #Viewpoint 20 20 0
		# Viewpoint 50 -130 0
                #surface 13 $min $max realx realy
                #Surface 13 $min $max realx realy
                #Surface 13 $min $max ix iy
                # default to not be log-log
                if(thebits & 0x100){\
                    set rlx=LG(realx)
                    #set rly=LG(realy)
                    Surface 103 $min $max rlx realy
                    relocate (17000 31500)
                    label RADIAL SCALE NOT CORRECT
                }\
                else{\
                    Surface 103 $min $max realx realy
                }
                define Lo_x ($txl)
                define Hi_x ($txh)
                define Lo_y ($tyl)
                define Hi_y ($tyh)
                box3
                labelaxes3 x1 x2 $2
                #device X11
vpl	19	# eg. vpl dump0001.dat v  1 12 010  <0 0 0 0>
		# vpl <file/0> <vec>   <v_leng> <12=xy,13=xz> <log&&overlay&&limits> <limits>
		# log=1 0=normal
		# overlay=0, no overlay, 1=overlay
		# limits=0 normal limits, 1=specified at line <limits>
                # this is a generic setup below(modified for 2 extra head entries
		# can control how many vectors reduced by defining SKIPFACTOR
                prepaxes x1 x2 $2
                if($?5 == 1) { define tobebits ($5) } else { define tobebits (0x0) }
                #defaults
                #expand 1.3
                #location 3500 17250 3500 31000
                location 3500 31000 3500 31000
                #window 2 1 1 1
                myrd $1
                if('$tobebits'=='000'){\
                 set thebits=0x0
		}\
                else{\
                 set thebits=0x$tobebits
		}
                if(thebits & 0x001){\
                  shrink3 $2x reallyx reallyy newfunx $6 $7 $8 $9
		  if($4==12){\
		   shrink3 $2y reallyx reallyy newfuny $6 $7 $8 $9
		  }
		  if($4==13){\
		   shrink3 $2z reallyx reallyy newfunz $6 $7 $8 $9
		  }
                  # do not change limits if overlay
		  if(!(thebits & 0x010)){\
                   limits $txl $txh $tyl $tyh
		  }
                  #image ($nx,$ny) $xl $xh $yl $yh
                  #image ($rnx,$rny)
                }\
                else{\
                   define xl ($Sx)
	   	   define xh ($Sx+$Lx)
		   define yl ($Sy)
		   define yh ($Sy+$Ly)
                   # do not change limits if overlay
		   if(!(thebits & 0x010)){\
                    limits $xl $xh $yl $yh
		   }
                   define txl ($xl)
                   define txh ($xh)
                   define tyl ($yl)
                   define tyh ($yh)
                   define rxl (0)
                   define rxh ($nx)
                   define ryl (0)
                   define ryh ($ny)
                   define rnx ($nx)
                   define rny ($ny)
                   #image ($nx,$ny) $xl $xh $yl $yh
                   #image ($nx,$ny) $rxl $rxh $ryl $ryh
                   #image ($nx,$ny)
		   set ii=1,$nx*$ny
                   set x=(ii - $nx*int((ii-0.5)/$nx) - 0.5)*$dx+$xl
		   set y=((int((ii-0.5)/$nx) + 0.5)*$dy)+$yl
		   set ix = int((x -$xl)/$dx)
		   set iy = int((y -$yl)/$dy)
                   #set reallyx=x1
                   #set reallyy=x2
                   set reallyx=x12
                   set reallyy=x22
                   set newfunx=$2x
		   if($4==12){\
		    set newfuny=$2y
	 	   }
		   if($4==13){\
		    set newfunz=$2z
	 	   }
	   	   # 
                }
                #limits $rxl $rxh $ryl $ryh
                #device ppm file1.ppm
                # default(0) to not overlay
                if(thebits & 0x010){\
                   define temptemptemp (1)
                }\
                else{
                 erase
		 ctype default
                 labeltime
                }
		#
		set ii=1,$rnx*$rny        
		if($SKIPFACTOR>1){\
		 #
		 set iy = int(ii/$rnx) + 1
		 set ix = ii - $rnx*(iy - 1)
		 set use = (int(iy/$SKIPFACTOR) - iy/$SKIPFACTOR == 0 && int(ix/$SKIPFACTOR) - ix/$SKIPFACTOR == 0) ? 1 : 0
		}\
		else{\
		        set use=ii/ii*1
		}
		set realx=reallyx if(use)
		set realy=reallyy if(use)
                if($4==13){\
			    set VVx = newfunx if(use)
		            set VVy = newfunz if(use)
			    }
		if($4==12){\
		       set VVx = newfunx if(use)
		       set VVy = newfuny if(use)
		       }
		set ang=180.*atan2(VVy,VVx)/pi
                # for cart coords only
                # spherical coord mapping not done here but in code using interpolation
		set leng=$3*sqrt(VVx**2 + VVy**2)
                if(thebits & 0x100){\
                 ticksize -1 0 0 0
		 #limits (LG(realx)) realy
		 limits (LG(realx)) realy
                 if(thebits & 0x010){\
		  define temptemp (0)
		 }\
		 else{\
		  box
		 }
		 #vfield (LG(realx)) realy leng ang
		 vfield (LG(realx)) realy leng ang
                }\
                else{\
                 ticksize 0 0 0 0
                 #vfield x1 x2 leng ang
                 vfield realx realy leng ang
                 if(thebits & 0x010){\
		  define temptemp (0)
		 }\
                 else{\
                  #mybox2d
                  box
		 }
		 labelaxes 1
                }
                #
pl	18	# pl <file> <dir> <function> <logx=1000,0000,logy=0100,0000,overlay=0010,0000,limits=0000,0001> <0 0 0 0>
                prepaxes $2 $3
                if($?4 == 1) { define tobebits ($4) } else { define tobebits (0x0) }
                #defaults
                myrd $1
                if( ('$tobebits'=='0000')||('$tobebits'=='0x0') ){\
                 set thebits=0x0
		}\
                else{\
                 set thebits=0x$tobebits
		}
		#
		#
                if(thebits & 0x1000){\
                 set rlx=LG(ABS($2))
		 if(thebits & 0x0001){\
		  set _newxl=LG($5)
		  define newxl (_newxl)
		  set _newxh=LG($6)
		  define newxh (_newxh)
		 }
                }\
                else{\
		 set rlx=$2
                 if(thebits & 0x0001){\
		  set _newxl=$5
		  define newxl (_newxl)
		  set _newxh=$6
		  define newxh (_newxh)
		 }
                }
                if(thebits & 0x0100){\
		 set rly=LG(ABS($3))
                 if(thebits & 0x0001){\
		  set _newyl=LG($7)
		  define newyl (_newyl)
		  set _newyh=LG($8)
		  define newyh (_newyh)
		 }
                }\
                else{\
		 set rly=$3
                 if(thebits & 0x0001){\
		  set _newyl=$7
		  define newyl (_newyl)
		  set _newyh=$8
		  define newyh (_newyh)
		 }
                }
	        if(!(thebits&0x0010)){\
		 if((thebits&0x1000)&&(thebits&0x0100)){\
		  #ticksize -.1 1 -1 10
		  ticksize -1 10 -1 10
		 }
		 if((thebits&0x1000)&&(!(thebits&0x0100))){\
		  ticksize -1 0 0 0
		 }
		 if((!(thebits&0x1000))&&(thebits&0x0100)){\
		  ticksize 0 0 -1 0
		 }
		 if((!(thebits&0x1000))&&(!(thebits&0x0100))){\
		  ticksize 0 0 0 0
		 }
		}
                # (ones->limits)
                # if ones==1 use input limits
                # else if ones==0 use standard limits
                # if tens=1 overlay
                if(thebits & 0x0010){\
		  # define your own ptype,ctype
                  define temptemptemp (0)
                }\
                else{\
                 if(thebits & 0x0001){\
		  limits  $newxl $newxh $newyl $newyh
                 }\
                 else{\
		  limits rlx rly
                 }
		 erase
		 labeltime
                }
		#
                mypoints rlx rly
                if(thebits & 0x0010){\
                  define temptemptemp (0)
                }\
                else{\
                  # use real names for labelaxes function
                  #labelaxes $2 $3
                  labelaxes 1
                  mybox1d 
                }
                # some non-general short cuts
plo     3       #
                pl $1 $2 $3 0010
pllim	7	#
                pl $1 $2 $3 0001 $4 $5 $6 $7
setlimits 6     # set limits for dotallslim
                  set lim2=0,5,1
                  set lim2[0]=$1
                  set lim2[1]=$2
                  set lim2[2]=$3
                  set lim2[3]=$4
                  set lim2[4]=$5
                  set lim2[5]=$6
                  define xl2 (lim2[0])
                  define xh2 (lim2[1])
                  define yl2 (lim2[2])
                  define yh2 (lim2[3])
                  define zl2 (lim2[4])
                  define zh2 (lim2[5])
                  #
gamgo           #
                cd /us2/jon/mhdt4/
                rdbasic 0 1 -1
                rd dump0026.dat          
                #rd dump0012.dat
                setlimits 0 6.28 3.14 3.14 0 1
		plflim 0 x1 p
                set it1=newfun
                setlimits 0 6.28 3.13 3.13 0 1
                plflim 0 x1 p
                set it2=newfun
                set itavg=0.5*(it1+it2)
                set myx=newx
                # gammie traces through y first!
                da /usr/u/gammie/rtwod/nonrel/dump010
                #da /usr/u/gammie/rtwod/nonrel/dump005
                lines 2 10000000
                read {x 1 y 2 rho 3 ux 4 uy 5 uz 6 Bx 7 By 8 Bz 9 u 10}
                define nx (512)
                define ny (512)
                set x12=pi+y # really y
                set x22=pi+x # really x
                set p=2.0/3.0*u
                setlimits 3.14 3.14 0 6.28 0 1
                ctype red plflim 0 x2 p
                set git1=newfun
                set gy=newx
                setlimits 3.13 3.13 0 6.28 0 1
                ctype red plflim 0 x2 p
                set git2=newfun
                set gavg=0.5*(git1+git2)
                #
                ptype 2 0
                ctype default pl 0 myx itavg
                points myx itavg
                ptype 4 0
                ctype red plo 0 gy gavg
                points gy gavg
plflim 15       #
                #plflim	15 : plflim <file> <dir> <function> <zlimit=0,1> <logx=100,000,logy=010,000,overlay=001,000>
                #eg. setlimits  1.0 1.4 0 3.14159 0 1 plflim dump0000.dat x1 r 0 100
                #eg. setlimits  0 4 1.55 1.58 0 1 plflim dump0000.dat x1 r 0 000
                # normal strong limits
                # setlimits  1 1.2 1.55 1.58 0 1 plflim dump0000.dat x1 r 0 000
                #
                if($?4 == 1) { define tobebits2 ($4) } else { define tobebits2 (0x0) }
                if($?5 == 1) { define tobebits ($5) } else { define tobebits (0x0) }
                if( ('$tobebits2'=='000')||('$tobebits2'=='0x0') ){\
                 set thebits2=0x0
		}\
                else{\
                 set thebits2=0x$tobebits2
		}
                if( ('$tobebits'=='000')||('$tobebits'=='0x0') ){\
                 set thebits=0x0
		}\
                else{\
                 set thebits=0x$tobebits
		}
                myrd $1
                shrink3 $3 reallyx reallyy newfun $xl2 $xh2 $yl2 $yh2
		if(('$2'=='x1')||('$2'=='x12')){\
                 set newx=reallyx
		 define newxl2 ($xl2)
		 define newxh2 ($xh2)
		}
		if(('$2'=='x2')||('$2'=='x22')){\
		 set newx=reallyy
		 define newxl2 ($yl2)
		 define newxh2 ($yh2)
		}
      	        if(thebits2 & 0x1){\
		 if(thebits & 0x111){
		  define newbits ($51)
                  pl 0 newx newfun $51 $newxl2 $newxh2 $zl2 $zh2
		 }\
                 else{\
                  pl 0 newx newfun 0001 $newxl2 $newxh2 $zl2 $zh2
		 }
		}\
                else{\
		 if(thebits & 0x111){
                  pl 0 newx newfun $50
		 }\
		 else{\
                  pl 0 newx newfun
		 }
		}
                #
pld	4	#
                #defaults
                myrd $1
                myrd $2 2
                set rdiff = r-r2
                set endiff = en-en2
                set sediff = se-se2
                set potdiff = pot-pot2
                set pdiff = p-p2
                set csdiff = cs-cs2
                set vxdiff = vx-v2x
                set vydiff = vy-v2y
                set vzdiff = vz-v2z
                set bxdiff = bx-b2x
                set bydiff = by-b2y
                set bzdiff = bz-b2z
                pl 0 $3 $4
pldo	4	#
                myrd $1
                myrd $2 2
                set rdiff = r-r2
                set endiff = en-en2
                set sediff = se-se2
                set potdiff = pot-pot2
                set pdiff = p-p2
                set csdiff = cs-cs2
                set vxdiff = vx-v2x
                set vydiff = vy-v2y
                set vzdiff = vz-v2z
		plo 0 $3 $4
pldlim	8	#
                #defaults
                myrd $1
                rd $2 2
                set rdiff = r-r2
                set endiff = en-en2
                set pdiff = p-p2
                set vxdiff = vx-v2x
                set vydiff = vy-v2y
                set vzdiff = vz-v2z
                set potdiff = pot-pot2
		limits $5 $6 $7 $8
		erase
                labeltime
                ctype default
		box
		ptype 4 0
		points $3 $4
		connect $3 $4
		xla $3
		yla $4
pldlimo	8	#
                myrd $1
                rd $2 2
                set rdiff = r-r2
                set endiff = en-en2
                set pdiff = p-p2
                set vxdiff = vx-vx2
                set vydiff = vy-vy2
                set vzdiff = vz-vz2
                set potdiff = pot-pot2
                ctype blue
		ptype 4 0
		points $3 $4
		connect $3 $4
		xla $3
		yla $4
pla	2	#
                #defaults
                myrd $1
		set ii=1,$nx*$ny
                set x=(ii - $nx*int((ii-0.5)/$nx) - 0.5)*$dx
		set y=(int((ii-0.5)/$nx) + 0.5)*$dy
		image ($nx,$ny) -.5 .5 -.5 .5
		set ix = int(x/$dx)
		set iy = int(y/$dy)
		set image (ix,iy) = $2[ii-1]
		#
		minmax min max echo $min $max
		#
		define delta (($max-$min)/10.)
		set lev=$min,-$delta,$delta
		levels lev
		ltype 2
		contour
		#
		set lev=$delta,$max,$delta
		levels lev
		ltype 0
		contour
		#
                # device postencap /us1/jon/compare/fiducial/r2d.eps
avgtime   1	# avgtime (e.g. avgtime 'dump')
		define DOCALCS 1
		define DOSTRESS 1
		#defaults
		rdnumd
                set h1=$1
                set h3='.dat'
		#
		set rtime=1,$nx*$ny*$nz,1
		set entime=1,$nx*$ny*$nz,1
                set betime=1,$nx*$ny*$nz,1
                set cs2time=1,$nx*$ny*$nz,1
                set stime=1,$nx*$ny*$nz,1
                set vtimex=1,$nx*$ny*$nz,1
                set vtimey=1,$nx*$ny*$nz,1
                set vtimez=1,$nx*$ny*$nz,1
		if($fullvec){\
		       set btimex=1,$nx*$ny*$nz,1
		       set btimey=1,$nx*$ny*$nz,1
		       set btimez=1,$nx*$ny*$nz,1
		       set vatime=1,$nx*$ny*$nz,1
		       set vatimex=1,$nx*$ny*$nz,1
		    }   
		if($DOSTRESS){\
		       set Fltime=1,$nx*$ny*$nz,1
		       set Flrtime=1,$nx*$ny*$nz,1
		       set Flmtime=1,$nx*$ny*$nz,1
		       set Mftimex=1,$nx*$ny*$nz,1
		       set Mftimey=1,$nx*$ny*$nz,1
		       set Lftimex=1,$nx*$ny*$nz,1
		       set Lftimey=1,$nx*$ny*$nz,1
		    }
		if($npdone){\
		       set sig11time=1,$nx*$ny*$nz,1
		       set sig12time=1,$nx*$ny*$nz,1
		       set sig13time=1,$nx*$ny*$nz,1
		       set sig22time=1,$nx*$ny*$nz,1
		       set sig23time=1,$nx*$ny*$nz,1
		       set sig33time=1,$nx*$ny*$nz,1
		       set Fvzdx=1,$nx*$ny*$nz,1
		       set Fvzdy=1,$nx*$ny*$nz,1            
		       set Fmdx=1,$nx*$ny*$nz,1
		       set Fmdy=1,$nx*$ny*$nz,1    
		    }
                #
                set rtime=rtime*0
                set entime=entime*0
                set betime=betime*0
                set cs2time=cs2time*0
                set stime=stime*0
                set vtimex=vtimex*0
                set vtimey=vtimey*0
                set vtimez=vtimez*0
		# below for stress plot
		if($DOSTRESS){\
		       set Fltime=Fltime*0
		       set Flrtime=Flrtime*0
		       set Flmtime=Flmtime*0
		       set Mftimex=Mftimex*0
		       set Mftimey=Mftimey*0
		       set Lftimex=Lftimex*0
		       set Lftimey=Lftimey*0
		    }
		if($fullvec){\
		       set btimex=btimex*0
		       set btimey=btimey*0
		       set btimez=btimez*0
		       set vatime=vatime*0		       
		       set vatimex=vatimex*0		       
		    }
		if($npdone){\
		       set sig11time=sig11time*0
		       set sig12time=sig12time*0
		       set sig13time=sig13time*0
		       set sig22time=sig22time*0
		       set sig23time=sig23time*0
		       set sig33time=sig33time*0
		       set Fvzdx=Fvzdx*0
		       set Fvzdy=Fvzdy*0
		       set Fmdx=Fmdx*0
		       set Fmdy=Fmdy*0
		    }
                #
		#set numstart=20
		#set numend=50
		set numstart=$NUMDUMPS/2
		set numend=$NUMDUMPS-1
		#set numstart=$NUMDUMPS/3
		#set numend=3*$NUMDUMPS/5
                set numtotal=numend-numstart+1
                do ii=numstart,numend,1 {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
		  rd $filename
                  set rtime=rtime+r
                  set entime=entime+en
                  set betime=betime+Be
                  set cs2time=cs2time+cs*cs
                  set stime=stime+entropy
                  set vtimex=vtimex+vx
                  set vtimey=vtimey+vy
                  set vtimez=vtimez+vz
		  if($fullvec){\
		         set btimex=btimex+bx
		         set btimey=btimey+by
		         set btimez=btimez+bz
		         set vatime=vatime+va
		         set vatimex=vatimex+vax
		      }
		  if($DOSTRESS){\
		         set Mftimex=Mftimex+Fmx
		         set Mftimey=Mftimey+Fmy
		         set Lftimex=Lftimex+Fvzx
		         set Lftimey=Lftimey+Fvzy
		         set Flrtime=Flrtime+(r*vx*vz)
		         set Fltime=Fltime+(r*vx*vz-bz*bx)
		         set Flmtime=Flmtime+(-bz*bx)
		      }
		  if($npdone){\
		             set sig11time=sig11time+sig11
		             set sig12time=sig12time+sig12
		             set sig13time=sig13time+sig13
		             set sig22time=sig22time+sig22
		             set sig23time=sig23time+sig23
		             set sig33time=sig33time+sig33
		             set Fvzdx=Fvzdx*0
		             set Fvzdy=Fvzdy*0
		             set Fmdx=Fmdx*0
		             set Fmdy=Fmdy*0
		          }
		}
                set rtime=rtime/numtotal
                set entime=entime/numtotal
                set betime=betime/numtotal
                set cs2time=cs2time/numtotal
                set stime=stime/numtotal
                set vtimex=vtimex/numtotal
                set vtimey=vtimey/numtotal
                set vtimez=vtimez/numtotal
		if($fullvec){\
		       set btimex=btimex/numtotal
		       set btimey=btimey/numtotal
		       set btimez=btimez/numtotal
		       set vatime=vatime/numtotal
		       set vatimex=vatimex/numtotal		       
		    }
		if($DOSTRESS){\
		           set Fltime=Fltime/numtotal
		           set Flrtime=Flrtime/numtotal
		           set Flmtime=Flmtime/numtotal
		           set Mftimex=Mftimex/numtotal
		           set Mftimey=Mftimey/numtotal
		           set Lftimex=Lftimex/numtotal
		           set Lftimey=Lftimey/numtotal
		        }
		if($npdone){\
		               set sig11time=sig11time/numtotal
		               set sig12time=sig12time/numtotal
		               set sig13time=sig13time/numtotal
		               set sig22time=sig22time/numtotal
		               set sig23time=sig23time/numtotal
		               set sig33time=sig33time/numtotal
		               set Fvzdx=Fvzdx/numtotal
		               set Fvzdy=Fvzdy/numtotal
		               set Fmdx=Fmdx/numtotal
		               set Fmdy=Fmdy/numtotal
		            }
		define DOCALCS 1      
                #
animvpl	19	# animvpl 'dump' v 1 12 10  <0 0 0 0>
                #defaults
                if($?5 == 0) { define numsend (4) }\
                else{\
                  if($?6 == 1) { define numsend (6) } else { define numsend 5 }
                }
		rdnumd
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  if($numsend==6){\
 		   vpl $filename $2 $3 $4 $5 $6 $7 $8 $9
                  }\
                  else{\
                   if($numsend==5){\
 		    vpl $filename $2 $3 $4 $5
                   }\
                   else{\
                    if($numsend==4){\
 		     vpl $filename $2 $3 $4
                    }
                   }
                  }
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
animvplp 19	# animvplp 'dump' v 1 4 10  <0 0 0 0>
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
		  vplp $filename $2 $3 $4 $5 $6 $7 $8 $9
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
		#
animplc	17	# animplc 'dump' r 000 <0 0 0 0>
                if($?3 == 0) { define numsend (2) }\
                else{\
                  if($?4 == 1) { define numsend (4) } else { define numsend 3 }
                }
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
		set endanim=$NUMDUMPS-1
		#set endanim=$NUMFLDUMPS-1 
                do ii=0,endanim,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  if($numsend==2){ plc  $filename $2}\
                  else{\
                   if($numsend==3){  plc  $filename $2 $3}\
                   else{\
                    if($numsend==4){ plc  $filename $2 $3 $4 $5 $6 $7}
                   }
                  }
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
		#
animzplc 17	# animzplc dump0000.dat r 000 <0 0 0 0>
                if($?3 == 0) { define numsend (2) }\
                else{\
                  if($?4 == 1) { define numsend (4) } else { define numsend 3 }
                }
                #defaults
		set startanim=-2
		set endanim=$nz-3
		define PLANE 3
		myrd $1
		define ii (startanim)
		#do ii=startanim,endanim,$ANIMSKIP {\
		while{1==1}{\
		  set iitemp=$ii
		  print '%d\n' {iitemp}
		  set $2new=$2 if(k==$ii)
                  if($numsend==2){ plc  0 $2new}\
                  else{\
                   if($numsend==3){  plc  0 $2new $3}\
                   else{\
                    if($numsend==4){ plc  0 $2new $3 $4 $5 $6 $7}
                   }
                  }
		  set iitemp=$ii+1
		  define ii (iitemp)
		  if($ii==endanim){ define ii (startanim) }
                  #delay loop
                  set j=0
                  while {j<10000} {set j=j+1}
		}
		#
animzpls 17	# animzplc dump0000.dat r 000 <0 0 0 0>
                if($?3 == 0) { define numsend (2) }\
                else{\
                  if($?4 == 1) { define numsend (4) } else { define numsend 3 }
                }
                #defaults
		set startanim=-2
		set endanim=$nz-3
		define PLANE 3
		myrd $1
		define ii (startanim)
		#do ii=startanim,endanim,$ANIMSKIP {\
		while{1==1}{\
		  set iitemp=$ii
		  print '%d\n' {iitemp}
		  set $2new=$2 if(k==$ii)
                  if($numsend==2){ pls  0 $2new}\
                  else{\
                   if($numsend==3){  pls  0 $2new $3}\
                   else{\
                    if($numsend==4){ pls  0 $2new $3 $4 $5 $6 $7}
                   }
                  }
		  set iitemp=$ii+1
		  define ii (iitemp)
		  if($ii==endanim){ define ii (startanim) }
                  #delay loop
                  set j=0
                  while {j<10000} {set j=j+1}
		}
		#
animplflc 17	# animplflc 'fldump' phibz 000 <0 0 0 0>
                if($?3 == 0) { define numsend (2) }\
                else{\
                  if($?4 == 1) { define numsend (4) } else { define numsend 3 }
                }
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
		set h32='.2.ppm'
		define ANIMSKIP 1
		define PLOTERASE 0
		define CONSTLEVELS 1
		define SKIPFACTOR 1
		define cres 100
		#set constlevelshit=0
		set constlevelshit=1
		define max 0
		#define min -3
		define min -2.98509     # make center touch with cres=100
		set start=0   # don't restart unless min/max are actually the same(or set the same)
		set finish=$NUMFLDUMPS-1
                do ii=start,finish,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
		  set _fname2=h1+h2+h32
		  define filename2 (_fname2)
		  #device ppm ./fppm/$filename2
		  device ppm1024 ./fppm/$filename2
                  if($numsend==2){ plc  $filename $2}\
                  else{\
                   if($numsend==3){  plc  $filename $2 $3}\
                   else{\
                    if($numsend==4){ plc  $filename $2 $3 $4 $5 $6 $7}
                   }
                  }
		  device X11
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
		define PLOTERASE 1
		set constlevelshit=0
		define CONSTLEVELS 0
		#
animpls	17	#
                if($?3 == 0) { define numsend (2) }\
                else{\
                  if($?4 == 1) { define numsend (4) } else { define numsend 3 }
                }
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  if($numsend==2){ pls  $filename $2}\
                  else{\
                   if($numsend==3){  pls  $filename $2 $3}\
                   else{\
                    if($numsend==4){ pls  $filename $2 $3 $4 $5 $6 $7}
                   }
                  }
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		} 
		#
animpl	18	#
                if($?4 == 0) { define numsend (3) }\
                else{\
                  if($?5 == 1) { define numsend (5) } else { define numsend 4 }
                }
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  if($numsend==3){ pl  $filename $2 $3}\
                  else{\
                   if($numsend==4){  pl  $filename $2 $3 $4}\
                   else{\
                    if($numsend==5){ pl  $filename $2 $3 $4 $5 $6 $7 $8}
                   }
                  }
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
animplflim  15	#
                # setlimits  1.0 1.4 0 3.14159 0 1 animplflim 'dump' x1 r 0 100
                if($?4 == 0) { define numsend (3) }\
                else{\
                  if($?5 == 1) { define numsend (5) } else { define numsend 4 }
                }
                #defaults
		rdnumd
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  if($numsend==3){ plflim  $filename $2 $3}\
                  else{\
                   if($numsend==4){  plflim  $filename $2 $3 $4}\
                   else{\
                    if($numsend==5){ plflim  $filename $2 $3 $4 $5}
                   }
                  }
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
animplo	3	#pl	18	# pl <file> <dir> <function> <logx=1000,0000,logy=0100,0000,overlay=0010,0000,limits=0000,0001> <0 0 0 0>
                animpl $1 $2 $3 0010
animpllim 7	#
                animpl $1 $2 $3 0001 $4 $5 $6 $7
                #
animplconv 3	#
                #defaults
		# when you read in text(h1) use ''s, eg. 'dump401'
                set h1=$1
                set h3='.dat'
                do ii=15,1024,10 {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h2+h1+h3
                  define filename (_fname)
		  pl $filename $2 $3
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}  
animpld 2	#
                #defaults
		rdnumd
		set h0='a'
                set h1='dump'
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  set _fname2=h0+h1+h2+h3
                  define filename2 (_fname2)
		  #pld $filename $filename2 $1 $2
                  pld $filename adump0000.dat $1 $2
                  #delay loop
                  #set j=0
                  #while {j<10000} {set j=j+1}
		}
                # when you read in a full path for macro read do: re "fullpath"
animpldconv 3	#
                #defaults
		set h0='a'
		# h1 is dumpxxx for filename in convergence test
                set h1=$1
                set h3='.dat'
                do ii=15,1024,10 {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h2+h1+h3
                  define filename (_fname)
                  set _fname2=h2+h0+h1+h3
                  define filename2 (_fname2)
		  pld $filename $filename2 $2 $3
                  #delay loop
                  #set j=0
                  #while {j<10000} {set j=j+1}
		}  
adv     1       #
		set exponent=-1
		# -1 for cartesian -2 for cyl -3 for spc
                set ii=1,$nx
                set arho=(1+.1*_time)**(exponent)*ii/ii
                set rdiff=arho-r
                set avel=.1*x/(1.0+.1*_time)
                set vdiff=avel-vx
                ctype blue 
		ptype 4 0
		points x $1
		connect x $1        
advd    1       #
		set exponent=-1
		# -1 for cartesian -2 for cyl -3 for spc
                set ii=1,$nx
                set arho=(1+.1*_time)**(exponent)*ii/ii
                set rdiff=arho-r
                set avel=.1*x/(1.0+.1*_time)
                set vdiff=avel-vx
                ctype default
		ptype 4 0
                limits x $1
                erase
                box
		points x $1
		connect x $1        
advdlim    5    #
                set ii=1,$nx
		set exponent=-1
		# -1 for cartesian -2 for cyl -3 for spc
                set arho=(1+.1*_time)**(exponent)*ii/ii
                set rdiff=arho-r
                set avel=.1*x/(1.0+.1*_time)
                set vdiff=avel-vx
                ctype default
		ptype 4 0
                limits $2 $3 $4 $5
                erase
                box
		points x $1
		connect x $1        
animadvd 1	#
		rdnumd
                set h1='dump'
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,1 {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
                  device 0
		  plx $filename $1
                  device X11
                  advd $1
                  #delay loop
                  #set j=0
                  #while {j<1} {set j=j+1}
		}
                #
plb	2	#
                #defaults
                rdbondi
		limits $1 $2
		erase
                ctype default
		box
		ptype 4 0
		points $1 $2
		connect $1 $2
		xla $1
		yla $2
plbo	2	#
                #defaults
                rdbondi
                ctype blue
		ptype 4 0
		points $1 $2
		connect $1 $2
		xla $1
		yla $2
                  ##################
                  ##################
                  ##################
                  ##################
                  #BEGIN SUPERPOSTPROCESS MACROS
                  #
                  #
                  #
                  #
plottype  2       #
                  if(!($finaldraft)){\
                   if($1==1){\
		    ltype 0
                    ptype 4 0
                    ctype default
		   }
                   if($1==2){\
		    ltype 0
                    ptype 4 0
                    ctype red
		   }
                   if($1==3){\
		    ltype 0
                    ptype 4 0
                    ctype blue
		   }
		  }\
                  else{\
                   if($1==1){\
                    ctype default
                    ltype 0
		   }
                   if($1==2){\
                    ctype default
                    ltype 3
		   }
                   if($1==3){\
                    ctype default
                    ltype 4
		   }
		  }
drawmline  4      #
                  lweight $PLOTLWEIGHT
                  relocate ($1 $2)
                  set _temp1x=$1+(($3-$1)/4)
                  set _temp2x=$1+2*(($3-$1)/4)
                  set _temp3x=$1+3*(($3-$1)/4)
                  set _temp4x=$1+4*(($3-$1)/4)
                  define temp1x (_temp1x) 
                  define temp2x (_temp2x) 
                  define temp3x (_temp3x) 
                  define temp4x (_temp4x) 
                  set _temp1y=$2+(($4-$2)/4)
                  set _temp2y=$2+2*(($4-$2)/4)
                  set _temp3y=$2+3*(($4-$2)/4)
                  set _temp4y=$2+4*(($4-$2)/4)
                  define temp1y (_temp1y) 
                  define temp2y (_temp2y) 
                  define temp3y (_temp3y) 
                  define temp4y (_temp4y) 
                  draw ( $temp1x $temp1y )
                  draw ( $temp2x $temp2y )
                  draw ( $temp3x $temp3y )
                  draw ( $temp4x $temp4y )
                  lweight $NORMLWEIGHT
                  #
mylegend   4      # (e.g. mylegend 3 a01 a02 a03)
                  define legendtype (1)
                  if($1>=1){\
		   if($legendtype==1){\
                    relocate (7500 29000)
                    label $2
                    ltype 0
                    drawmline 10000 29400 11000 29400
		   }
		   if($legendtype==2){\
                    relocate (10000 24000)
                    label $2
		   }
		  }
                  if($1>=2){\
		   if($legendtype==1){\
                    relocate (7500 28000)
                    label $3
                    ltype 3
                    drawmline 10000 28400 11000 28400
		   }
		   if($legendtype==2){\
                    relocate (23000 11000)
                    label $3
		   }
		  }
                  if($1>=3){\
		   if($legendtype==1){\
                    relocate (7500 27000)
                    label $4
                    ltype 4
                    drawmline 10000 27400 11000 27400
		   }
		   if($legendtype==2){\
                    relocate (10000 11500)
                    label $4
		   }
		  }
                  #
speclim1   2      #
                  erase
                  limits $1 $2
                  box
                  #
speclim2   4      #
                  erase
                  limits $1 $2 $3 $4
                  box
                  #
justpllim  6      # just plot (e.g. justpllim 2 a01 a02 0 a01 a01)
                  mdotpl $1 $2 $3 $4 $5 $6
                  emdotpl $1 $2 $3 $4 $5 $6
                  mx3mdotpl $1 $2 $3 $4 $5 $6
                  #                  
dotalllim  6      # do full dot stuff (e.g. dotalllim 2 a01 a02 0 a01 a01)
                  set goldentemp=0
                  dotdo $1 $2 $3 $4
                  justpllim $1 $2 $3 $4 $5 $6
setlim     8      # set limits for dotallslim
                  # <tl,th,mdotlmdoth,emdotl,emdoth,mx3mdotl,mx3mdoth>
                  set lim=0,7,1
                  set lim[0]=$1
                  set lim[1]=$2
                  set lim[2]=$3
                  set lim[3]=$4
                  set lim[4]=$5
                  set lim[5]=$6
                  set lim[6]=$7
                  set lim[7]=$8
                  #
justplslim  4     # just plot (e.g. justplslim 2 a01 a02 0)
                  set goldentemp=1  # passed var
                  set tlim=0,1,1
                  set mlim=0,1,1
                  set emlim=0,1,1
                  set mx3mlim=0,1,1
                  set tlim[0]=lim[0]
                  set tlim[1]=lim[1]
                  set mlim[0]=lim[2]
                  set mlim[1]=lim[3]
                  set emlim[0]=lim[4]
                  set emlim[1]=lim[5]
                  set mx3mlim[0]=lim[6]
                  set mx3mlim[1]=lim[7]
                  mdotpl $1 $2 $3 $4 tlim mlim 
                  emdotpl $1 $2 $3 $4 tlim emlim
                  mx3mdotpl $1 $2 $3 $4 tlim mx3mlim
                  set goldentemp=0
                  #
dotallslim 4      # do full dot stuff (e.g. dotalllim1 2 a01 a02 0
                  # assumes lim[8] is set with limits
                  dotdo $1 $2 $3 $4
                  justplslim $1 $2 $3 $4
                  #
justpl    4       # just plot (e.g. justpl 2 a01 a02 0)
                  set goldentemp=0
                  mdotpl $1 $2 $3 $4 $2 $2
                  emdotpl $1 $2 $3 $4 $2 $2
                  mx3mdotpl $1 $2 $3 $4 $2 $2
                  #
dotall     4      # do full dot stuff (e.g. dotall 2 a01 a02 0)
                  # limits based upon first entry for both x/y
                  set goldentemp=0
                  dotdo $1 $2 $3 $4
                  justpl $1 $2 $3 $4
                  #
redloss    0      # reduce mdot/edot/mx3dot to managable size
                  define AUTOREDUCE (500)
                  # autoreduce size to 5000 points max
                  set lossdimen=INT(dimen(t)/$AUTOREDUCE)
                  if(lossdimen>1){\
                        set factor=lossdimen
                        reduce t min1 tr min1r factor
                        reduce t ein1 tr ein1r factor
                        reduce t mx3in1 tr mx3in1r factor
                  }\
                  else{\
                        set min1r=min1
                        set ein1r=ein1
                        set mx3in1r=mx3in1
                        set tr=t
                  }
                  #
dotdo     4       # upto 3 compares
                  # (e.g. dotdo 2 a01 a02 0)
                  # (e.g. dotdo 3 a01 a02 a03)
                   if($1>=1){\
                     rd /us1/jon/$2/0_loss.dat
                     redloss
                     der tr min1r td$2 min1d$2
                     der tr ein1r td$2 ein1d$2
                     der tr mx3in1r td$2 mx3in1d$2
                   }
                   if($1>=2){\
                     rd /us1/jon/$3/0_loss.dat
                     redloss
                     der tr min1r td$3 min1d$3
                     der tr ein1r td$3 ein1d$3
                     der tr mx3in1r td$3 mx3in1d$3
                   }
                   if($1>=3){\
                     rd /us1/jon/$4/0_loss.dat
                     redloss
                     der tr min1r td$4 min1d$4
                     der tr ein1r td$4 ein1d$4
                     der tr mx3in1r td$4 mx3in1d$4
                   }
                   #
mdotpl     6       # upto 3 compares
                   do kk=0,10,1{
                    set min1da06[$kk]=min1da06[11]
                   }
		   if($ploverlay==0){\
                     LOCATION 5000 31000 3500 31000
		   }
                   # (e.g. mdotpl 3 a01 a02 a03 a01 a02)
                   define CONVT1 (1)
                   #define CONVT1 (7960)
                   define CONVT2 (1)
                   #define CONVT2 (7960)
                   define CONVT3 (1)
                   #                   
                   #define CONV1 (8040.2)
                   define CONV1 (1)
                   #define CONV2 (8040.2)
                   define CONV2 (1)
                   define CONV3 (1)
                   do kk=0,$PRINTTO,1{
		      if($ploverlay==0){\
                    if($kk==1){\
                     if($1==1){\
                       device postencap /us1/jon/compare/dot/$2mdot.eps
                     }
                     if($1==2){\
                       device postencap /us1/jon/compare/dot/$2$3mdot.eps
                     }
                     if($1==3){\
                       device postencap /us1/jon/compare/dot/$2$3$4mdot.eps
                     }
                    }
                    ctype default
                    if(goldentemp==1){\
		           speclim1 $5 $6
                    }\
                    else{\
    	              if('$5'=='$2'){ define CTL ($CONVT1) }
                      if('$5'=='$3'){ define CTL ($CONVT2) }
                      if('$5'=='$4'){ define CTL ($CONVT3) }
                      if('$6'=='$2'){ define CFL ($CONV1) }
                      if('$6'=='$3'){ define CFL ($CONV2) }
                      if('$6'=='$4'){ define CFL ($CONV3) }
                      speclim1 ($CTL*td$5) ($CFL*min1d$6)
                    }
                    # new units
		           xla t c^3/GM
		           # new units injection
		           yla \dot{M}/\dot{M}_{inj}
                    if(!($finaldraft)){\
                     relocate (15000 31500)
                     if($1==1){\
                        ctype default label $2 \dot{M}/\dot{M}_{inj}
                     }
                     if($1==2){\
                        ctype default label $2 $3 \dot{M}/\dot{M}_{inj}
                     }
                     if($1==3){\
                        ctype default label $2 $3 $4 \dot{M}/\dot{M}_{inj}
                     }
		    }\
                    else{\
		            if($ploverlay==0){\
		            mylegend $1 $2 $3 $4
		         }
		    }
		 }
                    if($1>=1){\
		       plottype 1 $2
                       plo 0 ($CONVT1*td$2) ($CONV1*min1d$2)
                    }
                    if($1>=2){\
		       plottype 2 $3
                       plo 0 ($CONVT2*td$3) ($CONV2*min1d$3)
                    }
                    if($1>=3){\
		       plottype 3 $4
                       plo 0 ($CONVT3*td$4) ($CONV3*min1d$4)
                    }
                    if($kk==1){\
                     device X11
                    }
		   
                   }
emdotpl    6       # upto 3 compares
                   do kk=0,20,1{
                    set ein1da06[$kk]=ein1da06[21]
                    #set ein1da02[$kk]=ein1da02[21]
                   }
                   define CONVT1 (1)
                   #define CONVT1 (7960)
                   define CONVT2 (1)
                   #define CONVT2 (7960)
                   define CONVT3 (1)
                   define CONV1 (1)
                   #define CONV1 (.00252519)
                   define CONV2 (1)
                   #define CONV2 (.00252519)
                   define CONV3 (1)
                   do kk=0,$PRINTTO,1{
		      if($ploverlay==0){\

                    if($kk==1){\
                     if($1==1){\
                       device postencap /us1/jon/compare/dot/$2emdot.eps
                     }
                     if($1==2){\
                       device postencap /us1/jon/compare/dot/$2$3emdot.eps
                     }
                     if($1==3){\
                       device postencap /us1/jon/compare/dot/$2$3$4emdot.eps
                     }
                    }
                    ctype default
                    if(goldentemp==1){\
                      speclim1 $5 $6
                    }\
                    else{\
                      if('$5'=='$2'){ define CTL ($CONVT1) }
                      if('$5'=='$3'){ define CTL ($CONVT2) }
                      if('$5'=='$4'){ define CTL ($CONVT3) }
                      if('$6'=='$2'){ define CFL ($CONV1) }
                      if('$6'=='$3'){ define CFL ($CONV2) }
                      if('$6'=='$4'){ define CFL ($CONV3) }
                      speclim1 ($CTL*td$5) ($CFL*ein1d$6/min1d$6)
                    }
		 
                    # new units
                    xla t c^3/GM
                    # new units injection
                    yla \dot{E}/(\dot{M}c^2)
		 
                    if(!($finaldraft)){\
                     relocate (15000 31500)
                     if($1==1){\
                        ctype default label $2 \dot{E}/\dot{M}/c^2
                     }
                     if($1==2){\
                        ctype default label $2 $3 \dot{E}/\dot{M}/c^2
                     }
                     if($1==3){\
                        ctype default label $2 $3 $4 \dot{E}/\dot{M}/c^2
                     }
		    }\
                    else{\
                     mylegend $1 $2 $3 $4
		    }
		   }
                    if($1>=1){\
		     plottype 1 $2
		     plo 0 ($CONVT1*td$2) ($CONV1*ein1d$2/min1d$2)
                    }
                    if($1>=2){\
		       plottype 2 $3
                       plo 0 ($CONVT2*td$3) ($CONV2*ein1d$3/min1d$3)
                    }
                    if($1>=3){\
		       plottype 3 $4
                       plo 0 ($CONVT3*td$4) ($CONV3*ein1d$4/min1d$4)
                    }
                    if($kk==1){\
                     device X11
                    }
                   }
mx3mdotpl    6       # upto 3 compares
                   do kk=0,10,1{
                    set mx3in1da06[$kk]=mx3in1da06[11]
                   }
                   define CONVT1 (1)
                   #define CONVT1 (7960)
                   define CONVT2 (1)
                   #define CONVT2 (7960)
                   define CONVT3 (1)
                   define CONV1 (1)
                   #define CONV1 (20.1005)
                   define CONV2 (1)
                   #define CONV2 (20.1005)
                   define CONV3 (1)
                   do kk=0,$PRINTTO,1{
		   if($ploverlay==0){\
                    if($kk==1){\
                     if($1==1){\
                       device postencap /us1/jon/compare/dot/$2mx3mdot.eps
                     }
                     if($1==2){\
                       device postencap /us1/jon/compare/dot/$2$3mx3mdot.eps
                     }
                     if($1==3){\
                       device postencap /us1/jon/compare/dot/$2$3$4mx3mdot.eps
                     }
                    }
                    ctype default
                    if(goldentemp==1){\
                      speclim1 $5 $6
                    }\
                    else{\
                      if('$5'=='$2'){ define CTL ($CONVT1) }
                      if('$5'=='$3'){ define CTL ($CONVT2) }
                      if('$5'=='$4'){ define CTL ($CONVT3) }
                      if('$6'=='$2'){ define CFL ($CONV1) }
                      if('$6'=='$3'){ define CFL ($CONV2) }
                      if('$6'=='$4'){ define CFL ($CONV3) }
                      speclim1 ($CTL*td$5) ($CFL*mx3in1d$6/min1d$6)
                    }
                    # new units
                    xla t c^3/GM
                    # new units injection
                    yla (\dot{L}/\dot{M})(c/GM)
                    if(!($finaldraft)){\
                     relocate (15000 31500)
                     if($1==1){\
                        ctype default label $2 (\dot{L}/\dot{M})(c/GM)
                     }
                     if($1==2){\
                       ctype default label $2 $3 (\dot{L}/\dot{M})(c/GM)
                     }
                     if($1==3){\
                        ctype default label $2 $3 $4 (\dot{L}/\dot{M})(c/GM)
                     }
		    }\
                    else{\
                     mylegend $1 $2 $3 $4
		    }
		 }
                    if($1>=1){\
		       plottype 1 $2
                       plo 0 ($CONVT1*td$2) ($CONV1*mx3in1d$2/min1d$2)
                    }
                    if($1>=2){\
		       plottype 2 $3
                       plo 0 ($CONVT2*td$3) ($CONV2*mx3in1d$3/min1d$3)
                    }
                    if($1>=3){\
		       plottype 3 $4
                       plo 0 ($CONVT3*td$4) ($CONV3*mx3in1d$4/min1d$4)
                    }
                    if($kk==1){\
                     device X11
                    }
                   }
                   # cp *.m /us1/jon/ndata25
                   # device postscript
                   # define interp (0) set _gam=(5/3) define gam (_gam) set wgam=1
                   # label n17 n16 n25 \dot{M}(t)
                   #label Mass Accretion rate vs. time
myplotdo1   0      #
                   rdbasic 1 0 -1
                   rd idump0090.dat
                   rd i0_avg2d.dat
                   rd icdump.dat
                   plc 0 r
myplotbubble 0     #
		   erase
		   device postencap /us1/jon/compare/a1all/2d/bubblecontour.eps
		   define loginterprho 1
		   define cres 20
                   define x1label "R c^2/GM"    
		   define x2label "z c^2/GM"
		   labelaxes 0
		   limits x12 x22
		   mybox2d
		   plc 0 lr 010
		   define loginterprho 0
		   set itx=Fmdx*(x12*x12+x22*x22)
		   set ity=Fmdy*(x12*x12+x22*x22)
		   vplp 0 it 50 4 010
		   device X11
myplot1   0        #
                   window 1 1 1 1
                   notation -4 4 -4 4
                   #myplotdo1
                   erase
                   #now setup
                   device postencap /us1/jon/compare/a1all/2d/4panel.eps
                   window -2 -2 1 2 box 0 2 0 0
                   yla z c^2/GM
		   set lr=LG(r)
		   define cres 20
		   define loginterprho 1
                   plc 0 lr 010
		   define loginterprho 0
                   window -2 -2 2 2 box 0 0 0 0
		   define cres 50
                   plc 0 be2d 010
                   window -2 -2 1 1 box 1 2 0 0
                   xla R c^2/GM
                   yla z c^2/GM
                   set tempx=Fmdx*(x12*x12+x22*x22)
                   set tempy=Fmdy*(x12*x12+x22*x22)
                   vplp 0 temp 20 4 010
                   window -2 -2 2 1 box 1 0 0 0
                   xla R c^2/GM
                   set tempx=Lx*SQRT(x12*x12+x22*x22)
                   #set tempx=Lx
                   set tempy=Ly*SQRT(x12*x12+x22*x22)
                   #set tempy=Ly
                   vplp 0 temp 800 4 010
                   device X11
                   #
myplotdo2   0      # so do not have to keep doing this
                   rd 0_loss.dat
                   redloss
                   der tr min1r td min1d
                   der tr ein1r td ein1d
                   der tr mx3in1r td mx3in1d
myplot2   0        #
                   ltype 0
                   window 1 1 1 1
                   notation -4 4 -4 4
                   #myplotdo2
                   erase
                   #now setup
                   device postencap /us1/jon/compare/a1all/time/3dotpanel.eps
                   #
                   limits td min1d
                   window -8 -3 2:8 3 box 0 2 0 0
		   yla \dot{M}/\dot{M}_{inj}
                   plo 0 td min1d
                   #
                   set tempf=ein1d/min1d
                   limits td -.07 .005
                   #limits td tempf
                   window -8 -3 2:8 2 box 0 2 0 0
                   yla \dot{E}/(\dot{M}c^2)
		   ltype 0
                   plo 0 td tempf
		   ltype 1
                   set blah=(td+1E-6)/(td+1E-6)*(-.0625)
		   plo 0 td blah
		   relocate (25000 13800)
		   expand 1.1
                   label thin disk
		   expand 1.5
                   #
                   set tempf=mx3in1d/min1d
                   #limits td tempf
		   limits td 0 4.1
                   window -8 -3 2:8 1 box 1 2 0 0
		   yla (\dot{L}/\dot{M})(c/GM)
                   xla t c^3/GM
		   ltype 0
                   plo 0 td tempf
		   ltype 1
                   set blah=(td+1E-6)/(td+1E-6)*3.67423
		   plo 0 td blah
		   relocate (25000 11000)
		   expand 1.1
                   label thin disk
		   expand 1.5
                   device X11
                   #
myplotdo3   0      #
                   rdbasic 0 0 -1
                   rd dump0000.dat
                   rd 0_avg1d.dat
myplot3   0        #
		   ltype 0
                   window 1 1 1 1
		   ticksize -1 0 -1 0
                   #myplotdo3
                   erase
                   #now setup
                   device postencap /us1/jon/compare/a1all/1d/41dpanel.eps
		   #set lx1=LG(x1)
		   #set lr=LG(r)
		   #set lcs2=LG(csq1d2)
		   #set vk=SQRT(x12)/(x12-2)
		   #set vkn=SQRT(x12)/(x12)
		   #set lvzk=LG(vz/vk)
		   #set lvz=LG(vz)
		   #set lvk=LG(vk)
		   #set lvkn=LG(vkn)
		   #set lvx=LG(ABS(vx))
		   theta2davg PI/36 r2d r2davg newx1
		   theta2davg PI/36 cs22d cs22davg newx1
		   theta2davg PI/36 v2dx v2davgx newx1
		   theta2davg PI/36 v2dz v2davgz newx1
		   # set r2davg=r2d
		   # set cs22davg=cs22d
		   # set v2davgx=v2dx
		   # set v2davgz=v2dz
                   notation -1 1 -1 1
                   setlimits 2.0 600 1.55 1.58 0 1
		   #
		   limits (LG(newx1)) -3.7 -2.2
                   window 30 2 2:16 2 box 1 2 0 0
		   xla r c^2/GM
		   yla \rho (GM)^2/(\dot{M}_{inj} c^3)		   
                   #plflim 0 x1 r2davg 0 111
		   pl 0 newx1 r2davg 1110
		   # fix vk and vkn
                   #
                   limits (LG(newx1)) -4 -.5
                   window 30 2 16:30 2 box 1 2 0 0
		   xla r c^2/GM
		   yla (c_s/c)^2
                   #plflim 0 x1 cs22davg 0 111
		   pl 0 newx1 cs22davg 1110
                   #
                   limits (LG(newx1)) -1.6 .4
                   window 30 2 16:30 1 box 1 2 0 0
		   xla r c^2/GM
		   #yla v^{\phi}/v_k
                   yla v^{\phi}/c
                   #plflim 0 x1 v2davgz 0 111
		   pl 0 newx1 v2davgz 1110
		   set vkx1=newx1 if(newx1>6)
		   set vk=SQRT(vkx1)/(vkx1-2)
		   set vkn=SQRT(vkx1)/(vkx1)
                   ltype 3
                   #plflim 0 x1 vk 0 111
		   pl 0 vkx1 vk 1110
                   ltype 4
                   #plflim 0 x1 vkn 0 111
		   pl 0 vkx1 vkn 1110
                   ltype 0
		   #
                   limits (LG(newx1)) -3.5 0.2
                   window 30 2 2:16 1 box 1 2 0 0
		   xla r c^2/GM
		   yla |v^{r}|/c
                   #plflim 0 x1 v2davgx 0 111
		   pl 0 newx1 v2davgx 1110
                   #
                   device X11
                   #
                   #
myplotdo5 0        #
		dotdo 3 a01 a02 a06
myplot5  0         # just plot (e.g. justpllim 2 a01 a02 0 a01 a01)
		define PRINTTO 0
		  window 1 1 1 1
                  set goldentemp=1  # passed var
		  define ploverlay 1
		  setlim 0 7E5 0 .07 -.1 0 -1 3
                  set tlim=0,1,1
                  set mlim=0,1,1
                  set emlim=0,1,1
                  set mx3mlim=0,1,1
                  set tlim[0]=lim[0]
                  set tlim[1]=lim[1]
                  set mlim[0]=lim[2]
                  set mlim[1]=lim[3]
                  set emlim[0]=lim[4]
                  set emlim[1]=lim[5]
                  set mx3mlim[0]=lim[6]
                  set mx3mlim[1]=lim[7]
		  #
		  notation -2 2 -2 2
		  erase
		  device postencap /us1/jon/compare/dot/a01a02a06mdot.eps
		  limits tlim mlim
		  window -8 -2 2:8 1 box 1 2 0 0
                  mdotpl 2 a01 a02 0 tlim mlim
		  yla \dot{M}/\dot{M}_{inj}
		  xla t c^3/GM
		  window -8 -2 2:8 2 box 0 2 0 0
		  mdotpl 2 a01 a06 0 tlim mlim
		  # new units injection
		  yla \dot{M}/\dot{M}_{inj}
		  device X11
		  #
		  erase
		  device postencap /us1/jon/compare/dot/a01a02a06emdot.eps
		  limits tlim emlim
		  window -8 -2 2:8 1 box 1 2 0 0
                  emdotpl 2 a01 a02 0 tlim emlim
		  yla \dot{E}/(\dot{M}c^2)
		  xla t c^3/GM
		  window -8 -2 2:8 2 box 0 2 0 0
		  emdotpl 2 a01 a06 0 tlim emlim
		  # new units injection
		  yla \dot{E}/(\dot{M}c^2)
		  device X11
		  #
		  erase
		  device postencap /us1/jon/compare/dot/a01a02a06mx3mdot.eps
		  limits tlim mx3mlim
		  window -8 -2 2:8 1 box 1 2 0 0
                  mx3mdotpl 2 a01 a02 0 tlim mx3mlim
		  yla (\dot{L}/\dot{M})(c/GM)
		  xla t c^3/GM
		  window -8 -2 2:8 2 box 0 2 0 0
		  mx3mdotpl 2 a01 a06 0 tlim mx3mlim
		  # new units injection
		  yla (\dot{L}/\dot{M})(c/GM)
                  set goldentemp=0
		  define ploverlay 0
		  device X11
myplottest   0     #
                   window 1 1 1 1
                   #rdbasic 1 0 -1
                   #rd idump0100.dat
                   #rd i0_avg2d.dat
                   #rd icdump.dat
                   #plc 0 r
                   erase
                   #now setup
                   #device postencap /us1/jon/compare/a1all/2d/4panel.eps
                   window -2 -2 1 2 box 0 2 0 0
                   #yla z c^2/GM
                   window -2 -2 2 2 box 0 0 0 0
                   window -2 -2 1 1 box 1 2 0 0
                   #xla R c^2/GM
                   #yla z c^2/GM
                   window -2 -2 2 1 box 1 0 0 0
                   #xla R c^2/GM
                   #device X11
                   # old setlim:
                   # a01a02a06
                   # setlim 0 7E5 0 .07 -.1 0 -1 3
                   # f06f03f11
                   # setlim 0 1.2E5 0 .2 -.1 .1 -1 2
                   # n17n16n25
                   # setlim 0 1E5 0 .04 -.05 0 2 5
                   # n16f02f05
                   # setlim 0 8E5 0 .04 -.035 -.02 2.5 4
                   # n16f02f05
                   # setlim 0 8E5 0 .04 -.035 -.02 3 4
                   # n26n25
                   # setlim 0 2.6E4 0 .05 -.25 -.22 3.2 3.6
                   # n16n28n30
                   # setlim 0 1E5 .025 .045 -.035 -.01 3.3 3.6
myplotfft1   0     #
		   erase
                   device postencap /us1/jon/compare/fft/f02n23fftmdot.eps
                   limits  -5 -1 -12 -4
		   window 2 2 1:2 1
                   rd /us1/jon/n23/0_loss.dat
                   der t min1 td min1d
                   fftreallim 1 td min1d freq min1dfpow 2001 6730
                   set freq[0]=freq[1]
                   set min1dfpow[0]=min1dfpow[1]
                   set fn=freq if(freq>0)
                   set pn=min1dfpow if(freq>0)
                   set freq=fn
                   set min1dfpow=pn
                   pl 0 freq min1dfpow 1110
                   xla Hz GM/c^3
		   yla Power (\dot{M}_{inj} GM/c^3)^2
                   box 1 2 0 0
                   #
                   limits  -5 -1 -18 -9
		   window 2 2 1:2 2
                   rd /us1/jon/f02/0_loss.dat
                   der t min1 td min1d
                   fftreallim 1 td min1d freq min1dfpow 20001 118000
                   set freq[0]=freq[1]
                   set min1dfpow[0]=min1dfpow[1]
                   set fn=freq if(freq>0)
                   set pn=min1dfpow if(freq>0)
                   reduce fn pn fr pr 50
                   set freq=fr
                   set min1dfpow=pr
                   pl 0 freq min1dfpow 1110
                   box 0 2 0 0
		   yla Power (\dot{M}_{inj} GM/c^3)^2
                   device X11
myplotmdotdo1 0    #
                   rd /us1/jon/n23/0_loss.dat
                   der t min1 tdn23 min1dn23
                   rd /us1/jon/f02/0_loss.dat
                   der t min1 tdf02 min1df02
                   reduce tdf02 min1df02 trf02 mrf02 100
                   pdimen trf02
                   set tdf02=trf02
                   set min1df02=mrf02
myplotmdot1   0    #
		   defaults
		   erase
                   device postencap /us1/jon/compare/dot/f02n23mdot.eps
                   limits tdn23 min1dn23
		   window 12 2 2:12 1 box 1 2 0 0
                   plo 0 tdn23 min1dn23
		   yla \dot{M}c^3/(\rho_0 (GM)^2)
		   xla t c^3/GM
                   #
                   limits tdf02 min1df02
		   window 12 2 2:12 2 box 1 2 0 0
                   plo 0 tdf02 min1df02
		   yla \dot{M}/\dot{M}_{inj}
		   xla t c^3/GM
                   device X11
myplotshock    0   #
                   erase
                   #
                   window 3 3 1 1
                   limits 0 1 -.1 1.1
                   lweight 2
                   box
                   lweight 3
                   connect x1 by
		   xla x
                   yla b_y
                   #
                   window 3 3 1 2
                   limits 0 1 -.1 0.4
                   lweight 2
                   box
                   lweight 3
                   connect x1 vx
		   xla x
                   yla v_x
                   #
                   window 3 3 1 3
                   limits 0 1 .15 1.1
                   lweight 2
                   box
                   lweight 3
                   connect x1 r
		   xla x
                   yla \rho
                   #
                   window 3 3 2 3
                   limits 0 1 .15 1.1
                   lweight 2
                   box
                   lweight 3
                   connect x1 p
		   xla x
                   yla p_g
                   #
                   window 3 3 2 2
                   limits 0 1 -.1 0.9
                   lweight 2
                   box
                   lweight 3
                   connect x1 vy
		   xla x
                   yla v_y
                   #
                   window 3 3 3 2
                   limits 0 1 -.1 1.1
                   lweight 2
                   box
                   lweight 3
                   connect x1 vz
		   xla x
                   yla v_z
                   #
                   window 3 3 2 1
                   limits 0 1 -.05 .55
                   lweight 2
                   box
                   lweight 3
                   connect x1 bz
		   xla x
                   yla b_z
                   #
                   window 3 3 3 1
                   limits 0 1 -2 40
                   lweight 2
                   box
                   lweight 3
		   set phi=180/PI*ATAN(bz/(by+1E-6))
                   connect x1 phi
		   xla x
		   yla \Phi [degrees]
                   #
                   window 3 3 3 3
                   limits 0 1 .85 1.9
                   lweight 2
                   box
                   lweight 3
		   set energy=0.5*r*(vx**2+vy**2+vz**2)+0.5*(bx**2+by**2+bz**2)+en
		   connect x1 energy
		   xla x
		   yla E_{tot} density
                   lweight 2
                   relocate (383 31500)
                   label b_x=0.7 t=0.16 (\rho,v_x,v_y,v_z,b_y,b_x,p_g)=(1,0,0,0,0,0,1) (0.3,0,0,1,1,0,0.2) \gamma=5/3
                   relocate (383 100)
                   label 300 zones Ryu/Jones95 4d
                  #                   
invertaxes 4      #
		  set $3=1,$nx*$ny,1
		  set $4=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
 		    set $3[$nx*$ny-1-i]=$1[i]
 		    set $4[$nx*$ny-1-i]=$2[i]
  		  }
rot180del 2       # cartesion coord only
                  # used with TVDLF all vars
                  # used with ZEUS with zone centered scalars
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
		    set $2[$ii]=$1[$nx*$ny-1-$ii]-$1[$ii]
  		  }
                  #
rot180del2 4       # cartesion coord only
                  # used with TVDLF all vars
                  # used with ZEUS with zone centered scalars
		  set $2=1,$3*$4,1
                  do ii=0,$3*$4-1,1 {
		    set $2[$ii]=$1[$3*$4-1-$ii]-$1[$ii]
  		  }
                  #  
rot180delv 2       # cartesion coord only
                  # use with ZEUS with zone centered vectors
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
		    set $2[$ii]=$1[$nx*$ny-1-$ii]+$1[$ii]
  		  }
                  #
rot180dvx 2       # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  #  used with ZEUS vx location as vector
                  # only thing neglected is i=-2 vx since i=N1+N1BND doesn't exist as symmetry pair
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
                   if( ($ii>=1)&&($ii % $nx) ){\
		    set $2[$ii]=$1[$ii]+$1[$nx*$ny-1+1-$ii]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180dvx2 4       # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  #  used with ZEUS vx location as vector
                  # only thing neglected is i=-2 vx since i=N1+N1BND doesn't exist as symmetry pair
		  set $2=1,$3*$4,1
                  do ii=0,$3*$4-1,1 {
                   if( ($ii>=1)&&($ii % $3) ){\
		    set $2[$ii]=$1[$ii]+$1[$3*$4-1+1-$ii]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180dvy 2       # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  # used with ZEUS vy location as vector
                  # only thing neglected is j=-2 vy since j=N2+N2BND doesn't exist as symmetry pair
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
                   if( $ii>=$nx ){\
		    set $2[$ii]=$1[$ii]+$1[$nx*$ny-1+$nx-$ii]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180dvy2 4       # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  # used with ZEUS vy location as vector
                  # only thing neglected is j=-2 vy since j=N2+N2BND doesn't exist as symmetry pair
		  set $2=1,$3*$4,1
                  do ii=0,$3*$4-1,1 {
                   if( $ii>=$3 ){\
		    set $2[$ii]=$1[$ii]+$1[$3*$4-1+$3-$ii]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180dvc 2           # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  # used with vectors on corners
                  # only thing neglected is i=-2,j=-2 v(on center) since i=N1+N1BND,j=N1+N2BND doesn't exist as symmetry pair
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
                   if( ($ii>=$nx+1)&&($ii % $nx) ){\
		    set $2[$ii]=$1[$ii]+$1[$nx*$ny-1-($ii-($nx+1))]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180dsc 2       # cartesion coord only(for LOOPF of pdump, full grid inputted)
                  # used with scalars on corners
                  # only thing neglected is i=-2,j=-2 v(on center) since i=N1+N1BND,j=N1+N2BND doesn't exist as symmetry pair
		  set $2=1,$nx*$ny,1
                  do ii=0,$nx*$ny-1,1 {
                   if( ($ii>=$nx+1)&&($ii % $nx) ){\
		    set $2[$ii]=$1[$ii]-$1[$nx*$ny-1-($ii-($nx+1))]
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
rot180diff1 2     # cartesion coord only (for LOOPF of pdump, full grid inputted)
                  # NOT CURRENTLY USED
		  set $2=1,$nx*$ny,1
 		  set ii=0,$nx*$ny-1,1
		  set tempvar=$1 if( (ii>=$nx+1)&&(ii % $nx) )
                  set jj=0      
                  do ii=0,$nx*$ny-1,1 {
                   if( ($ii>=$nx+1)&&($ii % $nx) ){\
		    set $2[$ii]=tempvar[jj]+tempvar[($nx-1)*($ny-1)-1-jj]
                    set jj=jj+1
		   }\
		   else{\
		    set $2[$ii]=0
		   }
  		  }
                  #
writedump  1         # can use this to output any vectors/scalars and interp them using pp run
		     define print_noheader (1)
		     #read {r$!!ext 1 en$!!ext 2 pot$!!ext 3 v$!!extx 4 v$!!exty 5 v$!!extz 6 b$!!extx 7 b$!!exty 8 b$!!extz 9}
                     set it=sprintf('%10s\n','\# fileversion filetype')
                     set crap1=1
                     set crap2=$DTYPE
		     print $1 '%6s%6d %6d\n' {it crap1 crap2}
                     set it=sprintf('%6s\n','\# t SAMPLE ZONEC')
                     set crap1=$time
                     set crap2=0
                     set crap3=0
		     print + $1 '%6s%6d %6d %6d\n' {it crap1 crap2 crap3}
                     set it3=sprintf('%6s\n','\# nx ny nz')
		     set crap1=$nx
		     set crap2=$ny
		     set crap3=1
		     print + $1 '%6s%6d %6d %6d\n' {it3 crap1 crap2 crap3}
                     set it=sprintf('%s\n','\# rho u pot  vx1  vx2 vx3 bx1 bx2 bx3')
		     print + $1 '%s' {it}
                     print + $1 '%21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g\n' {r2d en2d pot2d v2dx v2dy v2dz b2dx b2dy b2dz}
                     #print + $1 '%21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g %21.15g\n' {r en pot vx vy vz bx by bz}
		     define print_noheader (0)
                     #
thetaphiavg   4      # (e.g. thetaphiavg PI/6 infun outfun outx1)
		    # average is over all phi
                     set $3=1,$nx,1
		     set $3=0*$3
		     set $4=1,$nx,1
		     set $4=0*$4
		     do ii=0,$nx*$ny*$nz-1,1{
		      set indexi=INT($ii%$nx)
		      set indexj=INT(($ii%($nx*$ny))/$nx)
		      set indexz=INT($ii/($nx*$ny))
		      if( ABS(x2[$ii]-PI/2)<$1 ){\
		       set $3[indexi]=$3[indexi]+$2[$ii]*dx22[$ii]*dx32[$ii]
		       set $4[indexi]=x12[$ii]
		      }
		     }
		     if(2*$1>(x2[$nx*$ny-1]-x2[0])){ set rangex2=(x2[$nx*$ny-1]-x2[0]) } else{ set rangex2=2*$1 }
		     set rangex3=x3[$nx*$ny*$nz-1]-x3[0]
		     # correct for degeneracies
		     if($ny==1){ set rangex2=dx22[0] }
		     if($nz==1){ set rangex3=dx32[0] }		     
 		     set $3=$3/(rangex2*rangex3)
		     #
stressdoall          #
		     rdbasic 0 0 -1
		     ctype default
		     avgtime 'dump'
		     echo doing fl
		     thetaphiavg PI/6 Fltime avgfl newx1
		     echo doing flr
		     thetaphiavg PI/6 Flrtime avgflr newx1
		     echo doing flm
		     thetaphiavg PI/6 Flmtime avgflm newx1
		     echo doing en
		     thetaphiavg PI/6 entime avgen newx1
		     echo doing plot
		     stressplot
                     #
stressplot           #
		     erase
                     #device postencap stressnew.eps
		     set lgnewx1=LG(newx1)
		     limits lgnewx1 -8 -3
                     #limits x1 -8 -3
                     ticksize -1 0 -1 0
		     lweight 3
		     box
		     xla R c^2/GM
		     ltype 0
		     set max=avgflm
		     set press=avgen*($gam-1)
		     connect lgnewx1 (LG(ABS(max)))
		     ltype 3
		     connect lgnewx1 (LG(ABS(press)))
		     #device X11
		     ctype red connect lgnewx1 (-2.45-2*lgnewx1)
stressplot2           #
                     #device postencap stressnew.eps
                     limits x1 -8 -2
                     ticksize 0 0 -1 0
		     lweight 3
		     box
		     xla R c^2/GM
		     ltype 0
		     set max=avgmaxm if((x1>=2.4)&&(x1<=22.68))
		     set rey=avgmaxr if((x1>=2.4)&&(x1<=22.68))
		     set newx1=x1 if((x1>=2.4)&&(x1<=22.68))
		     connect newx1 (LG(ABS(max)))
		     ltype 3
		     connect newx1 (LG(ABS(rey)))
		     #device X11
stressplot3           #
                     #device postencap stressnew.eps
                     limits x1 -3 1
                     ticksize 0 0 -1 0
		     lweight 3
		     box
		     xla R c^2/GM
		     ltype 0
		     set max=avgmaxm if((x1>=2.4)&&(x1<=22.68))
		     set rey=avgmaxr if((x1>=2.4)&&(x1<=22.68))
		     set newx1=x1 if((x1>=2.4)&&(x1<=22.68))
		     connect newx1 (LG(ABS(max/rey)))
		     #device X11
perfsetup1  1        # rainman detail single cpu run
		     da $1
		     read {j 1 i 2 zc 3}
                     define coord (1)
                     define interp (0)
		     define ny (51)
		     define nx (63)
		     define dy (2)
		     define dx (2)
		     set x22=j
		     set x12=i
		     define Sx (0)
		     define Sy (0)
		     define Lx ($nx)
		     define Ly ($ny)
perfsetup3  1        #
		     da $1
		     read {j 1 i 2 zc 3}
                     define coord (1)
                     define interp (0)
		     define ny (32)
		     define nx (32)
		     define dy (16)
		     define dx (16)
		     set x22=j
		     set x12=i
		     define Sx (0)
		     define Sy (0)
		     define Lx ($nx)
		     define Ly ($ny)
perfsetup2  1        #
		     da $1
		     read {j 1 i 2 zc 3}
                     define coord (1)
                     define interp (0)
		     define ny (17)
		     define nx (10)
		     define dy (17)
		     define dx (17)
		     set x22=j
		     set x12=i
		     define Sx (0)
		     define Sy (0)
		     define Lx ($nx)
		     define Ly ($ny)
perfsetup4  1        # 4-cpu photon/rainman MPI detail run
		     da $1
		     read {j 1 i 2 zc 3}
                     define coord (1)
                     define interp (0)
		     define ny (30)
		     define nx (63)
		     define dy (2)
		     define dx (2)
		     set x22=j
		     set x12=i
		     define Sx (0)
		     define Sy (0)
		     define Lx ($nx)
		     define Ly ($ny)
perfsetup5  1        # 1-cpu sgi origins r10000
		     da $1
		     read {j 1 i 2 zc 3}
                     define coord (1)
                     define interp (0)
		     define ny (22)
		     define nx (32)
		     define dy (2)
		     define dx (2)
		     set x22=j
		     set x12=i
		     define Sx (0)
		     define Sy (0)
		     define Lx ($nx)
		     define Ly ($ny)
		     #fix up stupid spikes
		     #
perffix1     0        #
		     do ii=0,dimen(zc)-1,1{
  		      if(zc[$ii]<2.2E5){\
		       set zc[$ii]=zc[$ii-1]
		      }
		     }
		     #
grb          0       #
		     cd ~/papers
		     da 4br_grossc.duration
		     read {i 1 t50 2 ut50 3 st50 4 t90 5 ut90 6 st90 7}
		     set lt50=LG(t50)
		     set lt90=LG(t90)
		     set bin=-3,3,.1
		     set hist50=HISTOGRAM(lt50:bin)
		     set hist90=HISTOGRAM(lt90:bin)
plgrb        1       #
		     ticksize -1 0 0 0
		     erase
		     limits bin hist$1
		     box
		     connect bin hist$1
                     # split monopole
		     # set bx=(1/tan(x2)-cos(x2)/tan(x2)/cos(t0)+1/cos(t0)*sin(x2))/x1
                     # set by=(cos(x2)/cos(t0)-1)/r
plgrb2	     0       #
		     ticksize -1 0 0 0
		     #device ppm it.ppm
		     #erase
		     ctype default
		     ltype 0
		     limits bin hist50
		     box
		     connect bin hist50
		     ltype 2
		     connect bin hist90
		     xla seconds
		     yla number of bursts
velocities    0      #
		     set vx=v2dx
		     set vy=v2dy
		     set vz=v2dz
		     set va=ABS(va2d)
		     set vax=ABS(va2dx)
		     set cs=SQRT(cs22d)
		     ltype 0
		     theta2d PI/6 vx
		     pl 0 newx1 avgmax 1100
		     #pl 0 newx1 avgmax 1110
		     theta2d PI/6 va
		     #theta2d PI/6 vax
		     ltype 1
		     pl 0 newx1 avgmax 1110
		     ltype 2
		     theta2d PI/6 cs
		     pl 0 newx1 avgmax 1110
		     ltype 3
		     theta2d PI/6 vz
		     pl 0 newx1 avgmax 1110
		     ltype 4
		     pl 0 newx1 (SQRT(newx1)/(newx1-2)) 1110
		     #
mpiperf1      1      #
		     da $1
                     read {p0 1 p1 2 dist 3 len 4 time 5 rate 6}
		     pl 0 len rate 1000
		     ptype 4 1
		     points (LG(len)) rate
		     xla bytes
		     yla MB/s
accelerations  0     #
		     # accelerations
		     # lagrangian derivative term: (v\cdot\nalbda)v
		     vdotgradv v v atv 3 2
		     set atvx=-atvx
		     set atvy=-atvy
		     set atvz=-atvz
		     grad pot aphi 3 2
		     set aphix=-aphix
		     set aphiy=-aphiy
		     #
		     grad p ap 3 2
		     set apx=-apx/r
		     set apy=-apy/r
		     #
		     grad b2 abp 3 2
		     set abpx=-0.5*abpx 
		     set abpy=-0.5*abpy
		     #
		     vdotgradv b b atb 3 2
                     # the above has 3 components!
		     # now look at ratios
		     set rtvx=atvx/aphix
		     set rtvy=atvy/aphix
		     set rtvz=atvz/aphix		     
		     set rpx=apx/aphix
		     set rpy=apy/aphix		     
		     set rbpx=abpx/aphix
		     set rbpy=abpy/aphix
		     set rtbx=atbx/aphix
		     set rtby=atby/aphix
		     set rtbz=atbz/aphix
		     set totaccx=atvx+aphix+apx+abpx+atbx
		     set totaccy=atvy+aphiy+apy+abpy+atby
		     set totaccz=atvz+aphiz+apz+abpz+atbz		     
		     #
redcompare 0               #
		     rd /us2/jon/mhdsp00/0_loss.dat
		     der t min1 td min1d
		     set per=2*PI*80**1.5
		     set tnew=td/per
		     set mdot1=min1d/(452219.9508/per)
		     ctype red
		     pl 0 tnew mdot1 0110
                     #
redcompare2 0         #
		     rd /us3/jon/mhdtorin16/0_loss.dat 2
		     der t2 min12 td2 min1d2
		     set per=2*PI*80**1.5
		     set tnew2=td2/per
		     set mdot12=min1d2/(452219.9508/per)
		     ctype default
		     pl 0 tnew2 mdot12 0100
                     #
		     #
                     #
		     #
		     #
		     #
		     #
		     #
		     #
		     #
crap	0	     # must always have bottom macro
		     #
                     # modes
modesetup 0          #
		#set R0=15.3 # R0
		set R0=9.4 # R0
		set torbit=2*pi*(R0)**(1.5)
		#
modeplot 0           #
		     modesetup
		     rd 0_mode.dat
		     ctype default
                     #pl 0 (t/torbit) (rm1/rm0) 0101 0 15 1E-6 1E-0
		     #set m1=vm1x+1E-12
		     #set m0=vm0x+1E-12
		     set m0=rm0
		     set m1=rm1
		     #pl 0 (t/torbit) (m1/m0) 0101 (t[0]/torbit-.2) (t[dimen(t)-1]/torbit) 1E-6 1E+0
		     #pl 0 (t/torbit) (m1) 0101 (t[0]/torbit-.2) (t[dimen(t)-1]/torbit) 1E-6 1E+0
		     pl 0 (t/torbit) (m0)
modefit 0            #
		modesetup
		ctype default
		rd 0_mode.dat
		# choose mode to analyze
		set amp=rm1
		modefit1
		modefitder
		modefit2
		#modefinalplot
		#
modefit1 0           # choose time range of analysis
		     #set start=4       #21,22
		     #set start=5        #23
		     #set start=4 # 29
		     #set start=2 # 30		     
		     #set start=3.5        #24,25
		     #set start=45   # 26
		     #set start=50 # mid-22
		     #set end=6 # 21
		     #set end=8 # 22
		     #set end=6 # 23
		     #set end=16 #24,25
		     #set end=6 #29
		     #set end=66.25 # 26
		     #set end=67 # mid-22
		     #set end=4          # 30
		     set start=0.26 #mhdcart8
		     set end=0.54   #mhdcart8
		     set newtime=t/torbit		     
		     pl 0 newtime amp 0100
modefitder 0         #
		     der newtime amp newtimed ampd
		     set ampd[dimen(ampd)-1]=ampd[dimen(ampd)-2]  # fix dual time value at end
		     #
modefit2 0           #
                     set god=ampd/amp/(2*pi)
                     pl 0 newtimed god 0001 newtimed[0] newtimed[dimen(newtimed)-1] -5 5
		     set limtime=newtimed if((newtimed>start)&&(newtimed<end))
		     set limfun=god if((newtimed>start)&&(newtimed<end))
		     lsq limtime limfun newtime newfun rms
		     ctype red plo 0 newtime newfun
		     ctype default
		     set Omegam=SUM(newfun)/dimen(newfun)
		     set rms=$rms
		     set chi2=$CHI2
		     print 'Omega_m=%g rms=%g chi2=%g\n' {Omegam rms chi2}
modefinalplot 0      #
		     set beginii=0
		     set ii=0
		     while{newtime[ii]<start}{\
		      set ii=ii+1
		     }
		     set beginii=ii
		     ctype default pl 0 newtime amp 0100
		     ctype red pl 0 newtime (amp[beginii]*exp(2*pi*Omegam*(newtime-start))) 0110
		     #
modeanalyzev 2  # modeanalyzev v 1
		set new$1x=1,$nx,1
		set new$1y=1,$nx,1
		do ii=0,$nx*$nz-1,1 {
		 set indexi=INT($ii%$nx)
		 set indexj=INT(($ii%($nx*$ny))/$nx)
		 set indexz=INT($ii/($nx*$ny))
		 set new$1x[indexi+indexj*$nx]=0
		 set new$1y[indexi+indexj*$nx]=0
                }
		do ii=0,$nx*$nz-1,1 {
		 set indexi=INT($ii%$nx)
		 set indexj=INT(($ii%($nx*$ny))/$nx)
		 set indexz=INT($ii/($nx*$ny))
		 set new$1x[indexi+indexj*$nx]=new$1x[indexi+indexj*$nx]+$1x[$ii]*cos($2*x3[$ii])*dx32[$ii]
		 set new$1y[indexi+indexj*$nx]=new$1y[indexi+indexj*$nx]+$1y[$ii]*cos($2*x3[$ii])*dx32[$ii]
                }
		set newx=x12 if(k==0)
modeanalyzes 2  # modeanalyzes r 1
		set new$1=1,$nx,1
		do ii=0,$nx*$nz-1,1 {
		 set indexi=INT($ii%$nx)
		 set indexj=INT(($ii%($nx*$ny))/$nx)
		 set indexz=INT($ii/($nx*$ny))
		 set new$1[indexi+indexj*$nx]=0
                }
		do ii=0,$nx*$nz-1,1 {
		 set indexi=INT($ii%$nx)
		 set indexj=INT(($ii%($nx*$ny))/$nx)
		 set indexz=INT($ii/($nx*$ny))
		 set new$1[indexi+indexj*$nx]=new$1[indexi+indexj*$nx]+$1[$ii]*cos($2*x3[$ii])*dx32[$ii]
                }
		set newx=x12 if(k==0)
poledottotal  0  #
		rdbasic 0 0 -1  # to get DTs
		b2time 'dump'
		revertmin1
		gammieplot
b2time	1	#
		rdnumd
		set b2vstime=1,$NUMDUMPS,1
		set fieldtime=1,$NUMDUMPS,1
                set h1=$1
                set h3='.dat'
                do ii=0,$NUMDUMPS-1,$ANIMSKIP {
                  set h2=sprintf('%04d',$ii)
                  set _fname=h1+h2+h3
                  define filename (_fname)
		  rd $filename
		  polefield
		  set b2vstime[$ii]=avgmax
		  set fieldtime[$ii]=$time
		}
revertmin1 0    #
		rd 0_loss.dat
		set ii=0,dimen(min1)-1,1
		set min1new=min1 if(!(ii%(INT(_DTd/_DTloss))))
		der fieldtime min1new td min1d
gammieplot 0    #
		ctype default
		set b2omdot=b2vstime/min1d
		define x1label "t c^3/GM"
		define x2label "B_p^2/\dot{M}"
		pl 0 fieldtime b2omdot
		# below should be tuned
		#set inner=2*dimen(fieldtime)/3  # end of run
		#set outer=3*dimen(fieldtime)/3  # end of run
		set inner=dimen(fieldtime)/3 # normal run
		set outer=2*dimen(fieldtime)/3 # normal run
		avglim fieldtime b2omdot b2omdotavg inner outer
		print {b2omdotavg}
polefield 0     #
		set avgmax=1,1,1
		set num=1,1,1
		set avgmax=0*avgmax/avgmax
		set num=0*num/num
		set uses=0,$nx*$ny*$nz-1,1
		set uses=0*uses
		set pio4=0*uses+pi/4
		set newx22=ABS(x22-pi/2)
		set rin=0*uses+x12[0]
		set rout=0*uses+1.1*x12[0]
		set one=0*uses+1
		set uses=( (newx22>=pio4)&&(x12>=rin)&&(x12<=rout) ) ? 1 : 0
		do jj=0,$ny*$nx-1,1{
		   if(uses[$jj]==1){\
		       set avgmax=avgmax+b2[$jj]
		       set num=num+1
		    }      
 		}
		set avgmax=avgmax/num
		#
plotcontour 0    #
                 da data.txt
		 read {x 1 y 2 z 3}
                 # size of data
                 define rnx 6
                 define rny 6
                 # limits of data
                 define txl (0.0)
                 define txh (100.0)
                 define tyl (0.0)
                 define tyh (100.0)
		 # uniform grid dx for each direction
		 set temp=($txh-$txl)/($rnx-1)
                 define realdx (temp)
		 set temp=($tyh-$tyl)/($rny-1)
                 define realdy (temp)
                 # number of contours
                 define cres (10)
                 # whether to have solid contours or shaded for negative values
                 define SOLIDCONTOURS (0)
                 #
		 set ii=1,$rnx*$rny,1
		 set x=(ii - $rnx*int((ii-0.5)/$rnx) - 0.5)*$realdx+$txl
		 set y=((int((ii-0.5)/$rnx) + 0.5)*$realdy)+$tyl
		 set ix = int((x -$txl)/$realdx)
		 set iy = int((y -$tyl)/$realdy)
                 limits $txl $txh $tyl $tyh
 		 image ($rnx,$rny) $txl $txh $tyl $tyh
                 set image[ix,iy] = z
                 erase
		 minmax min max
                 echo "min:"$min "max:"$max
		 	if(($SOLIDCONTOURS==0)&&($min*$max < 0.)) {\
                        echo "pt:1"
			define delta (($max-$min)/$cres)
                        echo "delta:"$delta
                        if($min>-$delta){\
                          define min -$delta
                        }
			set lev=$min,-$delta,$delta
			levels lev
			ltype 4
			contour
			#
                        if($max<$delta){\
                          define max $delta
                        }
			set lev=$delta,$max,$delta
			levels lev
			ltype 0
			contour
		}
		if(($min<=0)&&($max<=0)) {\
                        echo "pt:2"
			set lev=$min,$max,($max-$min)/$cres
			levels lev
			#ltype 2
                        ltype 0
			contour
		}
		if(($SOLIDCONTOURS==1)||($min>=0)&&($max>=0)) {\
                        echo "pt:3"
			set lev=$min,$max,($max-$min)/$cres
			levels lev
                        ltype 0
			contour
                }
                box
                #


		
 #		read {m0 1 m1 2 m2 3 m3 4 m4 5 m5 6 m6 7 m7 8 m8 9 m9 10 m10 11 m11 12 m12 13 m13 14 m14 15 m15 16 m16 17 m17 18 m18 19 m19 20 m20 21 m21 22 m22 23 m23 24 m24 25}
# ((gam-1.0)*s[2][kk][jj][ii]+s[1][kk][jj][ii]*s[3][kk][jj][ii])*g[2][2][ii]*g[2][3][ii]*g[2][4][jj]*dx[1][2][jj]*dx[1][3][kk];
		
